{
  "url": "https://api.github.com/repos/facebook/react/issues/15893",
  "repository_url": "https://api.github.com/repos/facebook/react",
  "labels_url": "https://api.github.com/repos/facebook/react/issues/15893/labels{/name}",
  "comments_url": "https://api.github.com/repos/facebook/react/issues/15893/comments",
  "events_url": "https://api.github.com/repos/facebook/react/issues/15893/events",
  "html_url": "https://github.com/facebook/react/issues/15893",
  "id": 456483617,
  "node_id": "MDU6SXNzdWU0NTY0ODM2MTc=",
  "number": 15893,
  "title": "Feature Request: Keyed Hooks",
  "user": {
    "login": "Nathan-Fenner",
    "id": 6179181,
    "node_id": "MDQ6VXNlcjYxNzkxODE=",
    "avatar_url": "https://avatars1.githubusercontent.com/u/6179181?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Nathan-Fenner",
    "html_url": "https://github.com/Nathan-Fenner",
    "followers_url": "https://api.github.com/users/Nathan-Fenner/followers",
    "following_url": "https://api.github.com/users/Nathan-Fenner/following{/other_user}",
    "gists_url": "https://api.github.com/users/Nathan-Fenner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Nathan-Fenner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Nathan-Fenner/subscriptions",
    "organizations_url": "https://api.github.com/users/Nathan-Fenner/orgs",
    "repos_url": "https://api.github.com/users/Nathan-Fenner/repos",
    "events_url": "https://api.github.com/users/Nathan-Fenner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Nathan-Fenner/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2019-06-15T00:55:47Z",
  "updated_at": "2019-08-13T10:39:50Z",
  "closed_at": null,
  "author_association": "NONE",
  "body": "<!--\r\n  Note: if the issue is about documentation or the website, please file it at:\r\n  https://github.com/reactjs/reactjs.org/issues/new\r\n-->\r\n\r\n*Do you want to request a feature or report a bug?* **Request a Feature**\r\n\r\n# Previous Issues\r\n\r\n\"Keys for hooks\" was previously proposed in #14998 and closed without much discussion.\r\n\r\nSee below (\"Use Cases\") for particular use cases of keyed hooks, and why they provide a better, more-general solution than other approaches today.\r\n\r\n# Background: the rules of hooks\r\n\r\nThe [Rules of Hooks](https://reactjs.org/docs/hooks-rules.html) outline how React hooks are allowed to be called. The rules are the following:\r\n\r\n- Hooks can only be called *at the top level* from custom hooks or React components\r\n- The same hooks, in the same order, must be called from any component every time it renders (or every time some custom hook is called)\r\n\r\nThere are several good reasons for these rules:\r\n\r\n1. These rules enable the *implementation* of hooks to be simple (a global, incrementing counter identifies the state for each primitive hook).\r\n2. The rules enable the *syntax* of hooks to be simple (a sequence of function calls, in order, without explicitly threading state between them, and without needing to arrange them into e.g. an array)\r\n3. You can reason about hooks *independently* since they don't depend on what comes before / after them: this is what allows you to reason about custom hooks in a way that ignores their implementation\r\n4. The rules can be easily checked by static linters\r\n\r\nThe third rule is important because we want to be able to provide custom hooks whose implementations are \"black boxes\": we don't need to know how a hook works to know what it does. The only requirement is when we call custom hooks, we also follow the Rules. It's important that this change (or other changes to hooks; or the introduction of new primitive hooks) do not cause it to break.\r\n\r\nThe main limitation of these rules is that hooks must be arranged in a line. We'd like to be able to generalize to support *trees* of hooks. In particular, just like React identifies the state for a component by its location within its parents component tree, we'd like to be able to \"relax\" the rules of hooks enough that we can call hooks *conditionally or variably* without breaking any of (1) or (2) or (3) or (4).\r\n\r\n# Feature Overview\r\n\r\nAllow hooks to be **grouped and keyed**.\r\n\r\nThe example below demonstrates correct usage of the proposed API:\r\n\r\n```js\r\nimport * as React from 'react';\r\n\r\nfunction useLookupMultiple(letters) {\r\n    const lookups = React.useGroup(keyer => {\r\n        const values = [];\r\n\r\n        const valA = keyer('A', () => {\r\n            return useLookup('A');\r\n        });\r\n        values.push(valA);\r\n\r\n\r\n        for (const letter of letters) {\r\n            const valLetter = keyer(letter, () => {\r\n                 return useLookup(letter);\r\n            });\r\n            values.push(valLetter);\r\n        }\r\n\r\n        const valB = keyer('B', () => {\r\n            return useLookup('B');\r\n        });\r\n        values.push(valB);\r\n\r\n        return values;\r\n    });\r\n\r\n    return lookups;\r\n}\r\n```\r\n\r\n## New Rules of Hooks\r\n\r\n- Hooks still need to follow the old *rules of hooks*\r\n- `useGroup` is a new, primitive hook which must also obey the existing rules of hooks\r\n- *but* hooks can be called from one *new* place: the `keyer` function callback obtained from `useGroup`\r\n\r\nWe'll now go through the 4 properties outlined above and see that they still apply.\r\n\r\n## Property 1: Ease of Implementation\r\n\r\nToday, React essentially stores an array of \"memory cells\" for primitive hooks. A global counter is used to identify which cell is the \"current\" one, and each primitive hook increments this counter.\r\n\r\nTo implement `useGroup`, only a small detour is required:\r\n\r\n- The `useGroup` memory cell essentially holds the following state: `{key1: memoryCellArray1, key2: memoryCellArray2, key3: memoryCellArray3}`.\r\n- The passed `keyer` callback first replaces the global memory cell array with the one associated with the provided key; then it calls its passed callback; then it reverts the global memory cell array so that the group can continue\r\n\r\n## Property 2: Ease of Syntax\r\n\r\nThe existing hook syntax is unchanged. The new group syntax is somewhat unwieldier, but the basic concepts still apply: regular function calls (albeit inside callbacks similar to `useEffect` or `useReducer` although run synchronously within the render like the latter rather than the former). The clumsier syntax is actually a benefit, because this feature should be seldom used, except for making certain custom hooks more powerful (see below for the intended use-cases).\r\n\r\n## Property 3: Independence\r\n\r\nHooks remain independent from one another. Moreover, since hooks are clearly *grouped* as well as simply keyed, it's easy to tell the scope of keys; in particular, there's no (sensible) way to split a keyed group of hooks across multiple custom hooks (the groups form a clear hierarchy bounded by custom hook scopes), so they can still be understood completely independently.\r\n\r\n## Property 4: Easy Linting\r\n\r\nLinters would need to be updated in order to support this feature. Luckily, it's fairly easy! The same rules of hooks apply, except that hooks may also be called (at the top level of) the `keyer` callback argument obtained from `React.useGroup`.\r\n\r\n# Use Case: The Problem Today\r\n\r\nThe simplest use-case that demonstrates why keyed hooks would be useful is outlined here. The [EventSource](https://developer.mozilla.org/en-US/docs/Web/API/EventSource) API allows JavaScript to stream events. We can write a nice custom hook to subscribe to an endpoint in some component:\r\n\r\n```js\r\nexport function useEventSourceListener(url, listenCallback) {\r\n  const listenCallbackRef = React.useRef(listenCallback);\r\n\r\n  React.useEffect(() => {\r\n    // On re-render, the listener should be updated.\r\n    listenCallbackRef.current = listenCallback;\r\n  });\r\n\r\n  React.useEffect(() => {\r\n    const source = new EventSource(url);\r\n    source.onmessage = e => {\r\n      listenCallbackRef.current(e.data);\r\n    };\r\n    return () => {\r\n      source.close();\r\n    };\r\n  }, [url]);\r\n}\r\n```\r\n\r\nUsing it is pretty straight-forward:\r\n\r\n```js\r\nconst ExampleComponent = ({id}) => {\r\n    const [messages, setMessages] = React.useState([]);\r\n\r\n    useEventSourceListener(`https://example.com/stream/${id}`, newMessage => {\r\n        setMessages(current => current.concat([newMessage]);\r\n    });\r\n\r\n    return <ul>{messages.map((msg, index) => <li key={index}>{msg}</li>)}</ul>;\r\n}\r\n```\r\n\r\nThis hook worked great for me, until I realized that a particular event stream that I needed was sharded across multiple URLs!\r\n\r\n```js\r\nconst ExampleComponent = ({id}) => {\r\n    const [messages, setMessages] = React.useState([]);\r\n\r\n    const onNewMessage = newMessage => {\r\n        setMessages(current => current.concat([newMessage]);\r\n    };\r\n\r\n    useEventSourceListener(`https://example.com/stream/${id}/shard-1`, onNewMessage);\r\n    useEventSourceListener(`https://example.com/stream/${id}/shard-2`, onNewMessage);\r\n\r\n    return <ul>{messages.map((msg, index) => <li key={index}>{msg}</li>)}</ul>;  \r\n}\r\n```\r\n\r\nAnd now *this* works until it turns out that there are a dynamic number of URLs depending on `id`. Once that happens, you *can't* write this using React unless you're willing to very carefully violate the rules of hooks and also give up on certain maintainability benefits. For example, the following solution \"obeys the rules of hooks\" as far as React can tell at runtime (although it will fail decent lint checks):\r\n\r\n```js\r\nconst ExampleComponent = ({id, shards}) => {\r\n    return <ExampleComponentInternal key={shards.length} id={id} shards={shards} />\r\n};\r\n\r\nconst ExampleComponentInternal = ({id, shards}) => {\r\n    const [messages, setMessages] = React.useState([]);\r\n\r\n    const onNewMessage = newMessage => {\r\n        setMessages(current => current.concat([newMessage]);\r\n    };\r\n\r\n    for (const shard of shards) {\r\n        useEventSourceListener(`https://example.com/stream/${id}/${shard}`, onNewMessage);\r\n    }\r\n    return <ul>{messages.map((msg, index) => <li key={index}>{msg}</li>)}</ul>;  \r\n}\r\n```\r\n\r\nof course, this solution has a large number of problems:\r\n\r\n- if the number of shards changes, then any other state (e.g. forms) stored inside the component get thrown away, since the `key` changed\r\n- if the shards get reordered, then the connections will be dropped and re-instantiated, since each `useEventSourceListener` call only knows about itself!\r\n\r\nThese problems can be remedied in turn by the following solution:\r\n\r\n```js\r\nconst ListenerComponent = ({url, onNewMessage}) => {\r\n    useEventSourceListener(url, onNewMessage);\r\n    return null;\r\n}\r\n\r\nconst ExampleComponent = ({id, shards}) => {\r\n    const [messages, setMessages] = React.useState([]);\r\n\r\n    const onNewMessage = newMessage => {\r\n        setMessages(current => current.concat([newMessage]);\r\n    };\r\n\r\n    for (const shard of shards) {\r\n        useEventSourceListener(, onNewMessage);\r\n    }\r\n    return <>\r\n        {shards.map(shard => <ListenerComponent url={`https://example.com/stream/${id}/${shard}`} key={shard} />)}\r\n        <ul>{messages.map((msg, index) => <li key={index}>{msg}</li>)}</ul>\r\n    </>;\r\n}\r\n```\r\n\r\nThis solution finally works in React today. Unfortunately, that stops being true if instead `useEventSourceListener` returns any useful value: there's no way to (synchronously) pass a returned value up from those `ListenerComponent`s into `ExampleComponent`. Using refs and `useLayoutEffect` you can kinda fake this, but in particular there's no way to pass those values into subsequent hooks, because hooks can't be called inside `useEffect` or `useLayoutEffect` callbacks.\r\n\r\n\r\n# Use Case: The Solution\r\n\r\nUsing keyed hooks, we simply get:\r\n\r\n```js\r\nconst ExampleComponent = ({id, shards}) => {\r\n    const [messages, setMessages] = React.useState([]);\r\n\r\n    const onNewMessage = newMessage => {\r\n        setMessages(current => current.concat([newMessage]);\r\n    };\r\n\r\n    React.useGroup(keyer => {\r\n        for (const shard of shards) {\r\n            keyer(shard, () => {\r\n                useEventSourceListener(`https://example.com/stream/${id}/${shard}`, onNewMessage);\r\n           });\r\n        }\r\n    });\r\n    return <>\r\n        <ul>{messages.map((msg, index) => <li key={index}>{msg}</li>)}</ul>\r\n    </>;\r\n}\r\n```\r\n\r\nJust like components, we only need to distinguish our hooks calls among *siblings* with `keyer`. Since `useEventSourceListener` is itself already robust against changes to the URL, we don't need to include `id` inside `keyer`'s key argument.\r\n\r\n# General Rationale\r\n\r\nThe general rationale behind this approach is to provide better composition of *custom* hooks. One workaround for the above approach is to create a new `useMultipleEventSourceListener(urls, callback)`, but this approach has several major drawbacks:\r\n\r\n- First, the implementation is very complicated. The main appeal of hooks like `useEffect` is that they encapsulate all aspects of one feature: initialization and cleanup go together. Implementing `useMultipleEventSourceListener`, while possible, doesn't let us take advantage of this because we're stuck with doing all initialization / teardown / diffing of values ourselves, since React can no longer do it for us.\r\n\r\n- Second, it's not compositional. Why *should* I have to *re-implement* a complex function when a simple loop ought to suffice? In particular, it's at least plausible to implement `useMultipleEventSourceListener` because here I've written the original myself, but if the custom hook comes from some third party then it's no longer feasible to fork and implement a \"multiple\" version myself\r\n\r\n- Lastly, it makes nesting custom hooks inside each other non-compositional. Even if I implement and maintain a `useMultipleEventSourceListener`, if I want to call *that* hook multiple times, I'm out of luck; instead I need Consider the case where I find I have multiple calls to `useMultipleEventSourceListener`; in order to be able to handle *that*, I would need to be able to \r\n\r\n# Semantics in Detail\r\n\r\nI glossed over several minor semantic details that need to be covered:\r\n\r\n## What happens to `useState`/`useReducer` when their keys change?\r\n\r\nIf the key is \"new\" (i.e. **was not present** on the *previous* render) then the state is copied from the \"initial\" argument.\r\n\r\nIf the key is not \"new\" (i.e. it **was present** on the *previous* render) then the state is whatever was previously stored.\r\n\r\nBasically, if a key disappears and reappears later, the old state was lost. This is just like how components with `key` props behave (whether they're using class `state` or functional `useState`).\r\n\r\n## What happens to `useEffect`/`useLayoutEffect` when keys change?\r\n\r\nIf the key ceases to exist, then the cleanup code gets called (just like if the component unmounted).\r\n\r\nThis is simple, consistent, and easily understood. Again, it's just like putting the hooks inside children with `key` props that disappear. If hooks work in those situations, they'll likely work here as well.\r\n\r\n## What happens to `useRef` when keys change?\r\n\r\nThe reference is fresh every time the key is \"new\". In particular, if a key disappears and reappears, the old `current` value is lost.\r\n\r\n## What happens to `useContext`?\r\n\r\nNothing, `useContext` doesn't actually need memory cells at all.\r\n\r\n## What happens to `useDebugValue`?\r\n\r\nThe debug value can be listed alongside the key which it lies under.\r\n\r\n## What happens if the order of keys changes?\r\n\r\nNot much - since hooks are independent of each other (property 3 above) it doesn't (or shouldn't) matter what order they're called as long as the memory cell array is updated appropriately. The call order should always match the order they're called inside `useGroup`.\r\n\r\n## What happens if the same key is used twice?\r\n\r\nThere are two obvious approaches:\r\n\r\n- Make this an error (or an error-in-debug mode, much like having multiple children with the same `key` prop today)\r\n- Make subsequent calls a no-op\r\n\r\nThe latter option is occasionally more convenient but potentially very unsafe. The former is much better (especially because if it errors today, it can be changed to have alternative behavior in the future).\r\n\r\n## What happens if you call hooks inside `useGroup` but not inside a `keyer` callback?\r\n\r\nThis causes an implementation-defined error, just like other misuses of keys or hooks today. The rules of hooks let you call hooks inside `keyer` callbacks, but not inside the `useGroup` callback.\r\n\r\n## What happens if `keyer` escapes from the `useGroup` callback and gets called later?\r\n\r\nThis causes a best-effort implementation-defined error, just like other misuses of hooks today (e.g. as if you call `useState` inside of an event callback).\r\n\r\n# Conclusion\r\n\r\nReact hooks are really nice 🥇. There's just a few edge cases like the above where they don't quite cut it - providing keyed hooks would just make writing and using custom hooks that much nicer, and solve tons of issues that are currently just-out-of-reach in maintainable, easily-understood ways.",
  "closed_by": null
}
