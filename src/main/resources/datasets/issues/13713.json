{
  "url": "https://api.github.com/repos/facebook/react/issues/13713",
  "repository_url": "https://api.github.com/repos/facebook/react",
  "labels_url": "https://api.github.com/repos/facebook/react/issues/13713/labels{/name}",
  "comments_url": "https://api.github.com/repos/facebook/react/issues/13713/comments",
  "events_url": "https://api.github.com/repos/facebook/react/issues/13713/events",
  "html_url": "https://github.com/facebook/react/issues/13713",
  "id": 362967976,
  "node_id": "MDU6SXNzdWUzNjI5Njc5NzY=",
  "number": 13713,
  "title": "DOM Event Mount Target Considerations",
  "user": {
    "login": "philipp-spiess",
    "id": 458591,
    "node_id": "MDQ6VXNlcjQ1ODU5MQ==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/458591?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/philipp-spiess",
    "html_url": "https://github.com/philipp-spiess",
    "followers_url": "https://api.github.com/users/philipp-spiess/followers",
    "following_url": "https://api.github.com/users/philipp-spiess/following{/other_user}",
    "gists_url": "https://api.github.com/users/philipp-spiess/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/philipp-spiess/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/philipp-spiess/subscriptions",
    "organizations_url": "https://api.github.com/users/philipp-spiess/orgs",
    "repos_url": "https://api.github.com/users/philipp-spiess/repos",
    "events_url": "https://api.github.com/users/philipp-spiess/events{/privacy}",
    "received_events_url": "https://api.github.com/users/philipp-spiess/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 127893911,
      "node_id": "MDU6TGFiZWwxMjc4OTM5MTE=",
      "url": "https://api.github.com/repos/facebook/react/labels/Component:%20DOM",
      "name": "Component: DOM",
      "color": "fef2c0",
      "default": false
    },
    {
      "id": 710375792,
      "node_id": "MDU6TGFiZWw3MTAzNzU3OTI=",
      "url": "https://api.github.com/repos/facebook/react/labels/Type:%20Discussion",
      "name": "Type: Discussion",
      "color": "fef2c0",
      "default": false
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2018-09-23T19:00:28Z",
  "updated_at": "2018-10-21T01:54:00Z",
  "closed_at": null,
  "author_association": "COLLABORATOR",
  "body": "Given that we’re considering a [rewrite of the event system](https://github.com/facebook/react/pull/13613#issuecomment-420286431) and are thinking about [attaching events to the React root](https://github.com/facebook/react/issues/13525), I thought it would be fitting to explore all our options on where to mount the event listeners a little and combine all the knowledge that is scattered across the repo.\r\n\r\nIn general, there are three candidates for attaching event listeners:\r\n\r\n1. Document  Listeners\r\n2. React Root Listeners\r\n3. Element Listeners\r\n\r\nEvery option comes with shortcomings and I want to summarize what we’ve learned over the years.\r\n\r\n## Document Listeners\r\n\r\nHistorically, React always listened at the document level and implemented a synthetic event system to simulate capture and bubble phases inside the React tree. Most event listeners are listening at the bubble phase which means that users can still add capture-level document listeners and see them fire before React will process the event.\r\n\r\nAdditionally, not all events bubble in the DOM. To support bubbling for all events, React sometimes eagerly adds event listeners (media events, for example) or listens to the capture phase instead.\r\n\r\nWhile it usually works to leave the React event system and attach native listeners when needed, there are certain caveats that come with that. One example is that calling `.stopPropagation()` on a capture document-level listener has no effect (#12518, https://github.com/facebook/react/issues/285#issuecomment-253502585/). Another implication of this is that interoperability between other React roots or third-party frameworks will behave unexpectedly (#8117, #8693).\r\n\r\nSome browsers have certain optimizations in place that make handling of document listeners complicated (Safari is not properly bubbling when document listeners are used #12717, #12989 and Chrome doesn’t respect preventDefault() on touch start at the document level https://github.com/facebook/react/issues/11530#issuecomment-413704069).\r\n\r\nWe’re also never cleaning up document-level listeners (#7128).\r\n\r\nThere are certain benefits of this solution as well. Our current event system can use the same \"event bus\" to implement polyfills that require document based listeners. Implementation of portal-bubbling is easier because we only need to ensure that we’re already listening at the document of the portal target (more on that later).\r\n\r\n## React Root Listeners (#2043)\r\n\r\nOne solution to the issues outlined above is the use of React roots as the mount target for events. This would still rely on event delegation and would require a synthetic event system.\r\n\r\nRoot level listeners would certainly help make bubbling more robust when using multiple React instances since we no longer add all listeners at the same level. This will, however, only work for bubbling. Some events use capturing (`scroll`, `focus`, `blur`, `cancel`, and `close`) and would fire in an inverse bubble order (https://github.com/facebook/react/pull/8117#issuecomment-257024618, https://github.com/facebook/react/pull/12919#issuecomment-392556395). Capture handlers between multiple roots will also always fire in the wrong order.\r\n\r\nPortal bubbling will also become more complicated since we have to find out if the portal root is inside the react-root to see if we need to attach listeners to the portal root as well. Consider the following example, where we need to add listeners to the `#react-root` as well as the `#portal-root`:\r\n\r\n```html\r\n<body>\r\n  <div id=\"react-root\"></div>\r\n  <div id=\"portal-root\"></div>\r\n</body>\r\n```\r\n\r\nAnd compare it with this example, where we don’t need that:\r\n\r\n```html\r\n<body>\r\n  <div id=\"react-root\">\r\n    <div id=\"portal-root\"></div>\r\n  </div>\r\n</body>\r\n```\r\n\r\nI’ve compiled a list of previous implementation attempts and the issues that were pointed out as well:\r\n\r\n| Date          | PR                                          | Issues                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\r\n| ------------- | ------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| Oct&nbsp;2016 | https://github.com/facebook/react/pull/8117 | <ul><li>Enter/Leave Shims (https://github.com/facebook/react/pull/8117#issuecomment-256498143)</li><li>Issues when using the same instance of React (https://github.com/facebook/react/pull/8117#issuecomment-256503428)</li><li>Captured events (like focus in Firefox) will fire in reverse order (https://github.com/facebook/react/pull/8117#issuecomment-257024618)</li><li>iOS Tap Highlight (https://github.com/facebook/react/pull/8117#issuecomment-257105712, https://github.com/facebook/react/issues/12989#issuecomment-414266839)</li><li>Select Shims (https://github.com/facebook/react/pull/8117#issuecomment-270206114)</li></ul> |\r\n| Jun&nbsp;2016 | https://github.com/facebook/react/pull/7088 | <ul><li>Firefox v8.01 mousemove events (https://github.com/facebook/react/pull/7088#issuecomment-227191272)</li></ul>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\r\n| Aug&nbsp;2014 | https://github.com/facebook/react/pull/2050 | <ul><li>Enter/Leave Shims (https://github.com/facebook/react/pull/2050#issue-19863619)</li></ul>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\r\n\r\nIt’s probably possible to work around some/all of the issues. The invalid capturing order can be worked around by adding both a bubble and a capture listener for regular events and then only trigger the appropriate phase. The shims can probably be rewritten and if they need the document, additional listeners could be added. iOS tap highlight could be disabled via CSS. To get rid of some of the edge cases around events that don’t bubble in the browser, we should consider deprecating support for this all together.\r\n\r\n### New Features\r\n\r\nSince we’re taking the time to rethink the event system, I also want us to think about: **Passive Event Listeners (#6436)** and **Web Components (#7901, #9242)**.\r\n\r\nI think we _can_ (albeit with an additional implementation effort) support passive event systems while keep using event delegation: We’d add two different listeners (one for capturing and one for bubbling) and handle them as completely different events. \r\n\r\nSupport for shadow roots is a bit more complex as event delegation doesn’t really make sense there. We can’t easily consider the shadow root the same as a React root or a portal root since we can’t rely on adding listeners to the `#react-root` if it’s the parent of a shadow root. Consider the following case:\r\n\r\n```html\r\n<div id=\"react-root\">\r\n  <!-- Listening on #react-root will catch events inside the #portal-root -->\r\n  <div id=\"portal-root\"></div> \r\n  <!-- Listening on #react-root will NOT catch events inside the #shadow-root -->\r\n  <my-component id=\"shadow-root\"></my-component>\r\n</div>\r\n```\r\n\r\nThere’s a handy comparison of Custom Elements support of different JavaScript framework and [React can definitely do better](https://custom-elements-everywhere.com/#react). With the planned changes to the event system, we should work on that.\r\n\r\n## Element Listeners (sort of #4751)\r\n\r\nThere’s a more radical approach to changing the event system and that is to get rid of event delegation altogether. This is what happens in [Preact](https://github.com/developit/preact/wiki/Differences-to-React#whats-missing), [react-dom-lite](https://github.com/jquense/react-dom-lite/blob/master/src/events/index.js#L35-L36), [Vue.js](https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/test/unit/modules/vdom/modules/events.spec.js#L5-L14), and probably other frameworks as well (We should research Ember and Angular at this point).\r\n\r\nIn this case, it’s trivial to add support for passive event listeners and bubble/capture will behave as expected. It also allows us to completely remove the need of the synthetic event system as we could rely on the browser for this. We also know that some browsers can better optimize certain events if they are attached directly to the element (#1254, #1964).\r\n\r\nI can think of at least two major roadblocks for this, though:\r\n\r\n1. **Performance** \r\n   Event delegation avoids the need to `addEventListener()` for every element with an event handler. We should figure out how significant this overhead really is - especially while considering the possible bundle size improvement that should make initial-render faster again. This needs to be compared at a real-world application. \r\n\r\n   While doing some [very rough benchmarking](https://github.com/philipp-spiess/react-event-benchmark/tree/755b0e208e6ae920f5b44573f09ffb519eed47ba) (It’s a microbenchmark so the outcomes are not representative for real apps) of an event-system less React, I noticed that there’s another feature of event delegation that is often overlooked: setState batching. Right now, React knows when all event listeners are called and can batch setState calls until this is the case. I looked a bit into a [potential callback mechanism](https://github.com/philipp-spiess/request-post-events-callback) that would fire when all events are processed and before the next frame is drawn but I don’t think this is possible in all browsers. We have to evaluate the performance implications on a real-world application to see how bad this is and how often setState batching is occurring (we could still batch inside the same event listener).\r\n\r\n2. **Portal Bubbling**\r\n   The big issue I see with portal bubbling is that we still need to use event delegation on the portal roots to catch events that are only listened to in parents. In the write-up about React Fire (#13525), @gaearon mentioned that we could use re-dispatching of native events but that would still require us to set up the listeners first.\r\n\r\n## Further Considerations\r\n\r\n- The whole synthetic event system currently accounts for **~20%** of the React DOM bundle size. [Back in July](https://github.com/philipp-spiess/react/commit/b4fda332b2be55e1b12021bd60209c6b442c3cda) I worked on an example that removed everything event related and added a tiny Preact-like system to find out how much we can save. I didn’t look into edge cases too much but I already got most of the tests to pass.\r\n- In general we might also consider adding an API for installing global DOM event handlers (#285) since the upcoming concurrent mode will make it more complicated to listen to arbitrary non React-controlled events (because of them possibly being fired during render time slices). This discussion is out of scope for this write-up though but maybe good to keep in mind.\r\n\r\nThat’s all I have for now. I’m especially curious for ways how we could implement portal bubbling when using element listeners - I’d say this is the biggest uncertainty I have right now. 🙂 \r\n",
  "closed_by": null
}
