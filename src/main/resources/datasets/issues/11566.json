{
  "url": "https://api.github.com/repos/facebook/react/issues/11566",
  "repository_url": "https://api.github.com/repos/facebook/react",
  "labels_url": "https://api.github.com/repos/facebook/react/issues/11566/labels{/name}",
  "comments_url": "https://api.github.com/repos/facebook/react/issues/11566/comments",
  "events_url": "https://api.github.com/repos/facebook/react/issues/11566/events",
  "html_url": "https://github.com/facebook/react/issues/11566",
  "id": 274309362,
  "node_id": "MDU6SXNzdWUyNzQzMDkzNjI=",
  "number": 11566,
  "title": "[Umbrella] New algorithm for resuming interrupted work",
  "user": {
    "login": "acdlite",
    "id": 3624098,
    "node_id": "MDQ6VXNlcjM2MjQwOTg=",
    "avatar_url": "https://avatars0.githubusercontent.com/u/3624098?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/acdlite",
    "html_url": "https://github.com/acdlite",
    "followers_url": "https://api.github.com/users/acdlite/followers",
    "following_url": "https://api.github.com/users/acdlite/following{/other_user}",
    "gists_url": "https://api.github.com/users/acdlite/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/acdlite/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/acdlite/subscriptions",
    "organizations_url": "https://api.github.com/users/acdlite/orgs",
    "repos_url": "https://api.github.com/users/acdlite/repos",
    "events_url": "https://api.github.com/users/acdlite/events{/privacy}",
    "received_events_url": "https://api.github.com/users/acdlite/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 739761016,
      "node_id": "MDU6TGFiZWw3Mzk3NjEwMTY=",
      "url": "https://api.github.com/repos/facebook/react/labels/Component:%20Reconciler",
      "name": "Component: Reconciler",
      "color": "f9a798",
      "default": false
    },
    {
      "id": 710615342,
      "node_id": "MDU6TGFiZWw3MTA2MTUzNDI=",
      "url": "https://api.github.com/repos/facebook/react/labels/Type:%20Umbrella",
      "name": "Type: Umbrella",
      "color": "5319e7",
      "default": false
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2017-11-15T21:24:06Z",
  "updated_at": "2019-07-24T01:35:05Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "body": "*Resuming* is the ability to re-use fibers after they are interrupted by a higher-priority update. Take the following scenario: A component is updated at a normal, async priority. Before the update is finished processing, a higher-priority update is scheduled (let's say it's synchronous, though it could also be a higher-priority async update). The sync update *interrupts* the async update, leaving it unfinished. After the sync update finishes, we go back to processing the interrupted, async update. It's possible, and even likely, that the interrupted work wasn't touched by the sync work and can be *resumed* without starting over completely.\r\n\r\nThis is an important optimization for several async features we have in mind, including error handling, blockers, pre-rendering, and hidden priority.\r\n\r\nWe used to have an implementation of resuming that mostly worked but had some bugs. A few months ago, I spent some time [identifying the bugs using fuzz testing](https://github.com/facebook/react/pull/9952) and fixing them by iterating on the existing algorithm. I eventually got a [version working that passed all the tests](https://github.com/facebook/react/pull/9695). But even this version didn't have all of the features we wanted, and the algorithm seemed inherently flawed. So we decided it would be best to scrap the existing algorithm and revisit resuming in the future.\r\n\r\nWe now believe we have a better idea of how resuming should work. I'm going to split the work into multiple PRs, and use this issue to keep track of our progress.\r\n\r\nMy apologies if some of my descriptions are hard to follow. It can be difficult to describe without resorting to jargon. I'll iterate on this issue as I work.\r\n\r\n\r\nAlways reconcile against current child set (#11564)\r\n---------------------------------------------------\r\n\r\nThis is a small refactor that reflects what we already do without resuming: the set we reconcile against is always the current set. In the reverted resuming algorithm, the set we reconcile against was sometimes a work-in-progress set, and there are a few code paths that are left over from that implementation.\r\n\r\nStash interrupted children\r\n--------------------------\r\n\r\nWhen cloning a work-in-progress fiber from current, and there is already an existing work-in-progress that was interrupted, stash the interrupted work-in-progress children (and corresponding fields) in case we can reuse them later. In begin phase, add an additional check to see if incoming props/state match the interrupted props/state. If so, bail out and re-use the interrupted children. If not, the interrupted children are no longer useful, because we're about to re-render the parent and overwrite them. (Unmounted fibers actually can be re-used even if we re-render the parent; see next step.)\r\n\r\nThis gets us back to the same functionality we had in the old resuming algorithm. We can now resume interrupted children if we come back to it at the same priority at which it was originally rendered. The main limitation is that the work is lost if the parent is re-rendered at a higher priority.\r\n\r\n**Need a way to distinguish between a work-in-progress fiber and the \"previous current\" fiber*\r\n\r\nPool unmounted, interrupted children so they can resume even if parent re-renders at higher priority\r\n------------------------------------------------------------------------------------\r\n\r\nWhen a fiber is about to be re-rendered, and there are interrupted children that could not be reused, search through the interrupted children and find the ones that are unmounted (don't have an alternate). Stash the unmounted children in a separate set; they can be kept around indefinitely without being overwritten. This set acts like a pool of children. The next time the parent is re-rendered at the priority of the interrupted children, check the pool for matches before creating new fibers.\r\n\r\n",
  "closed_by": null
}
