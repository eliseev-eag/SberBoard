{
  "url": "https://api.github.com/repos/facebook/react/issues/14717",
  "repository_url": "https://api.github.com/repos/facebook/react",
  "labels_url": "https://api.github.com/repos/facebook/react/issues/14717/labels{/name}",
  "comments_url": "https://api.github.com/repos/facebook/react/issues/14717/comments",
  "events_url": "https://api.github.com/repos/facebook/react/issues/14717/events",
  "html_url": "https://github.com/facebook/react/pull/14717",
  "id": 404078635,
  "node_id": "MDExOlB1bGxSZXF1ZXN0MjQ4MzQyNzUx",
  "number": 14717,
  "title": "Partial Hydration",
  "user": {
    "login": "sebmarkbage",
    "id": 63648,
    "node_id": "MDQ6VXNlcjYzNjQ4",
    "avatar_url": "https://avatars2.githubusercontent.com/u/63648?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/sebmarkbage",
    "html_url": "https://github.com/sebmarkbage",
    "followers_url": "https://api.github.com/users/sebmarkbage/followers",
    "following_url": "https://api.github.com/users/sebmarkbage/following{/other_user}",
    "gists_url": "https://api.github.com/users/sebmarkbage/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/sebmarkbage/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/sebmarkbage/subscriptions",
    "organizations_url": "https://api.github.com/users/sebmarkbage/orgs",
    "repos_url": "https://api.github.com/users/sebmarkbage/repos",
    "events_url": "https://api.github.com/users/sebmarkbage/events{/privacy}",
    "received_events_url": "https://api.github.com/users/sebmarkbage/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 196858374,
      "node_id": "MDU6TGFiZWwxOTY4NTgzNzQ=",
      "url": "https://api.github.com/repos/facebook/react/labels/CLA%20Signed",
      "name": "CLA Signed",
      "color": "e7e7e7",
      "default": false
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2019-01-29T01:15:07Z",
  "updated_at": "2019-02-15T18:56:06Z",
  "closed_at": "2019-02-12T05:25:45Z",
  "author_association": "MEMBER",
  "pull_request": {
    "url": "https://api.github.com/repos/facebook/react/pulls/14717",
    "html_url": "https://github.com/facebook/react/pull/14717",
    "diff_url": "https://github.com/facebook/react/pull/14717.diff",
    "patch_url": "https://github.com/facebook/react/pull/14717.patch"
  },
  "body": "This adds a mechanism for partially hydrating a server rendered result while other parts of the page are still loading the code or data. This means that you can start interacting with parts of the screen while others are still hydrating.\r\n\r\n## Model\r\n\r\nIn this model you always have to hydrate the root content first because it is what provides props to the children, which can be of arbitrary complexity. The model assumes that the root of the app is designed to be relatively shallow and then each abstraction gets progressively more complex the deeper it gets. To become interactive faster, components in the tree can themselves use progressive enhancement to add more complexity after initial hydration.\r\n\r\n## API\r\n\r\nThis mechanism works on top of the `<Suspense fallback={...}>` API. With this PR, when we try to hydrate a Suspense component, we will immediately bail out and skip past it. We'll leave the server rendered content in place. Once we've finished a hydrating of everything not in a Suspense boundary, we'll commit it. Then the next frame we'll continue to hydrate the next Suspense boundary and so on. This is a breadth first hydration. This happens even if nothing suspends. \r\n\r\nThe reason for the breadth first hydration is because we need to fully complete the parent before we can make any updates to children. Once we have committed a parent, we can now prioritize any of the Suspense \"holes\" left dehydrated inside it - independently.\r\n\r\nThe reason this works with Suspense boundaries is that the parents already have to be resilient to the children not being fully resolved, but also because we can at any point trigger the fallback state to return to a consistent state.\r\n\r\nIf the Suspense component rerenders with new props or new context as input, before we've fully hydrated, we have two problems:\r\n\r\n1) We can no longer safely hydrate the subtree. React has a strong requirement that the initial render behaves just as it did on the server. This is a tradeoff that lets us avoid a lot of metadata added to the HTML. We can't make changes to a subtree without first rendering the initial state. After that we can make updates. In theory, we could store a snapshot of all contexts and props to solve this problem.\r\n\r\n2) However, semantically, changes to props or Context should change whatever was rendered. E.g. if that switch is from dark to light mode, then we can't just leave the existing content in place. Similar things happen with certain layouts or media queries.\r\n\r\nTherefore, the semantics here is that if that happens, then we'll delete the existing content and rerender it from scratch. If that suspends, we'll show the fallback.\r\n\r\nThis is an undesirable experience but reasonable compromise. To avoid this the product code must:\r\n\r\n- Ensure that unrelated updates bail out early. E.g. using `memo` or `shouldComponentUpdate`.\r\n- Avoid updates to top level Contexts.\r\n- If that can't be avoided, use a low priority update in Concurrent Mode, and long suspense durations. This will delay this scenario for as long as possible.\r\n\r\n## Quirks\r\n\r\nThis solution is susceptible to tearing issues, common in Flux stores, just like Concurrent Mode in general. E.g. if the store is mutated before the next level is hydrated, then we'll try to hydrate it with the wrong initial state. Therefore, stores need to be able to save a snapshot of their initial state for the duration of the hydration.\r\n\r\nIn the current version of this PR, hydration of suspense boundaries always gets scheduled as concurrent. I'm not sure if a non-concurrent mode of this even makes sense.\r\n\r\nHoisting state up to the root can be problematic because as these update they will pass their value down and rerender components that may not have fully hydrated yet which will put them in their fallback state. The key is to make any such state have a long expiration time and long suspense time so that if it happens, we have time to hydrate it beforehand. High-pri state should be local to components and not rerender at the top. Updates to top level state placed in Context will force the fallback state of the whole tree since it can affect everything and needs to be managed carefully.\r\n\r\nFor these reasons, it is important to carefully design the shell of the app so that different parts can operate independently for at least some period of time.\r\n\r\n## Progress\r\n\r\nLeft to do in this PR:\r\n\r\n- [x] Wrap in feature flag\r\n- [x] Delete the content when any parent Context updates.\r\n- [x] Deal with Suspense boundaries without fallback defined.\r\n\r\nFollow up 1:\r\n\r\n- [ ] If props or context has changed, first try hydrating at higher priority in case that lets us hydrate.\r\n- [ ] Mark fallback content in the server rendered content. Wait to try to hydrate it until it switches to real content.\r\n- [ ] Gracefully handle sync mode (including strict mode) or disable it completely.\r\n- [ ] Add warnings for failing to hydrate suspense boundaries.\r\n\r\nFollow up 2:\r\n\r\n- [ ] Add mechanism to defer and replay events that happen in dehydrated trees.\r\n- [ ] Use deferred events as hints for which trees to prioritize.\r\n- [ ] If a deferred event can't be replayed on a hydrated tree within an expiration time, delete the content and show fallback.\r\n- [ ] Consider hydrating each level at a higher priority than \"offscreen\", or let hydration take priority over updates to the same trees.\r\n\r\n",
  "closed_by": {
    "login": "sebmarkbage",
    "id": 63648,
    "node_id": "MDQ6VXNlcjYzNjQ4",
    "avatar_url": "https://avatars2.githubusercontent.com/u/63648?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/sebmarkbage",
    "html_url": "https://github.com/sebmarkbage",
    "followers_url": "https://api.github.com/users/sebmarkbage/followers",
    "following_url": "https://api.github.com/users/sebmarkbage/following{/other_user}",
    "gists_url": "https://api.github.com/users/sebmarkbage/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/sebmarkbage/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/sebmarkbage/subscriptions",
    "organizations_url": "https://api.github.com/users/sebmarkbage/orgs",
    "repos_url": "https://api.github.com/users/sebmarkbage/repos",
    "events_url": "https://api.github.com/users/sebmarkbage/events{/privacy}",
    "received_events_url": "https://api.github.com/users/sebmarkbage/received_events",
    "type": "User",
    "site_admin": false
  }
}
