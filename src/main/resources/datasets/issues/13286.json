{
  "url": "https://api.github.com/repos/facebook/react/issues/13286",
  "repository_url": "https://api.github.com/repos/facebook/react",
  "labels_url": "https://api.github.com/repos/facebook/react/issues/13286/labels{/name}",
  "comments_url": "https://api.github.com/repos/facebook/react/issues/13286/comments",
  "events_url": "https://api.github.com/repos/facebook/react/issues/13286/events",
  "html_url": "https://github.com/facebook/react/issues/13286",
  "id": 345547982,
  "node_id": "MDU6SXNzdWUzNDU1NDc5ODI=",
  "number": 13286,
  "title": "Discussion: Synchronous State Management and Async React",
  "user": {
    "login": "markerikson",
    "id": 1128784,
    "node_id": "MDQ6VXNlcjExMjg3ODQ=",
    "avatar_url": "https://avatars1.githubusercontent.com/u/1128784?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/markerikson",
    "html_url": "https://github.com/markerikson",
    "followers_url": "https://api.github.com/users/markerikson/followers",
    "following_url": "https://api.github.com/users/markerikson/following{/other_user}",
    "gists_url": "https://api.github.com/users/markerikson/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/markerikson/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/markerikson/subscriptions",
    "organizations_url": "https://api.github.com/users/markerikson/orgs",
    "repos_url": "https://api.github.com/users/markerikson/repos",
    "events_url": "https://api.github.com/users/markerikson/events{/privacy}",
    "received_events_url": "https://api.github.com/users/markerikson/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2018-07-29T17:30:12Z",
  "updated_at": "2018-08-03T01:13:26Z",
  "closed_at": "2018-08-02T13:32:41Z",
  "author_association": "NONE",
  "body": "The React team has put out a fair amount of info on the upcoming async React concepts, including time sliced rendering and Suspense.  They've also been in contact with the various state management library teams (Redux, MobX, and Apollo) to give us an early heads-up on how these libraries might need to change to work correctly with async React.\r\n\r\nAt this point I personally feel like I still have only a partial understanding of what types of changes are needed.  Quoting a discussion between Dan and myself in https://github.com/reduxjs/react-redux/pull/898#issuecomment-375790227 :\r\n\r\n> To the best of my understanding, these are the problems that React-Redux faces when trying to work with async React:\r\n\r\n> 1. React's time-slicing means that it's possible for other browser events to occur in between slices of update work. React might have half of a component tree diff calculation done, pause to let the browser handle some events, and something else might happen during that time (like a Redux action being dispatched). That could cause different parts of the component tree to read different values from the store, which is known as \"tearing\", rather than all components rendering based on the same store contents in the same diff calculation.\r\n\r\n> 2. Because of time-slicing, React also has the ability to set aside partially-completed tree diffs if a higher priority update occurs in the middle. It would fully calculate and apply the changes from the higher-priority change (like a textbox keystroke), then go back to the partially-calculated low-pri diff, modify it based on the completed high-pri update, and finish calculating and applying the low-pri diff.\r\n> In other words, React has the ability to re-order queued updates based on priority, but also will start calculating low-pri updates as soon as they're queued. That is not how Redux works out of the box. If I dispatch a \"DATA_LOADED\" action and then a \"TEXT_UPDATED\" action, the data load causes a new store state right away. The UI will eventually look \"right\", but the sequence of calculating and applying the updates was not optimal, because Redux pushed state updates into React in the order they came in.\r\n\r\n\r\nThere was also some relevant discussion on Twitter at https://twitter.com/dan_abramov/status/1010978574105567234 : \r\n\r\n> **swyx**: so if anything async react “absorbs into the platform” some tricky parts of state mgmt (more accurately, creates a priority queue for UI interactions, and pushes async deps to whatever cache lib people end up using). haha, i guess im too eagerly taking those for granted.\r\n\r\n> **dan_abramov**: yeah. For the best desired experience, it needs control over when to apply updates, and what version of state to render with. So if a lib wants to own that, it’s missing out (although could work by getting “deoptimized” to sync mode).  \r\n\r\n> **mweststrate**: For inspiration: Is there an abstract write down / complete overview of which conceptual operations need to be supported to fully support async? Fork + replay changes made in forks suffices? (hints about conflicts resolution?)  \r\n\r\n> **dan_abramov**: Paging acdlite who’s currently working out how to make Relay work with it\r\n> **dan_abramov**: I think the main idea is that either your thing is meant for UI state that changes with interactions (and then we need a way to “route” it through setState—so it needs to provide a reducer), or it's more like a data cache (in which case your own storage is fine if it’s immutable)\r\n> **dan_abramov**: There is a third option too (a mutable data cache) which is what Relay will end up being for now. But this means it “deopts” to sync mode in some cases.\r\n\r\n> **sebmarkbage**: Those are more downstream recommendations, not first principles. A first principles is that you need to be able to read consistent old versions so if a parent passes data, the child needs to be able to read the version that the parent passed even after it has changed later.\r\n> **sebmarkbage**: Another first principle is that you need to be able to make edits to old versions and also make the same edit on the latest version (rebase).\r\n\r\n> **dan_abramov**: How would you do it without letting React manage state for you? We don't explicitly tell libs “now is time to rebase”.\r\n\r\n> **mweststrate**: Would need some kind of hooks were React tells: I want to fork / rebase this prop?\r\n\r\nThe phrase \"deopts to sync mode\" was explained by Brian in https://github.com/facebook/react/issues/13186#issuecomment-403959161 : \r\n\r\n> State updates scheduled from componentDidMount or componentDidUpdate are processed synchronously and flushed before the user sees the UI update. This is important for certain use cases (e.g. positioning a tooltip after measuring a rendered DOM element). In the case we're describing, this means that users of your application will never even see the temporary stale value because React will process the new value (synchronously) before yielding.\r\n\r\n> That might sound like a good thing, but what if the re-render includes a lot of components or is slow for some other reason? Then it might impact the frame rate and cause your application to feel unresponsive. This is what we are referring to when we say that create-subscription de-opts to synchronous rendering mode in some cases.\r\n\r\nAlso, Andrew commented in https://twitter.com/acdlite/status/1015286450537951233 : \r\n\r\n> We've learned from our work making Relay interop with async React, will share more soon.\r\n\r\nFinally, there's some related discussion in https://github.com/reduxjs/react-redux/issues/890 .\r\n\r\nSo, at this point what I would particularly appreciate is further info on exactly what constraints a normally-synchronous state management lib like Redux or MobX needs to comply with in order to work correctly with async React behavior, and any suggestions on possible implementations.  It would also be extremely beneficial if we could come up with some demo apps that specifically demonstrate problematic interactions between async React and synchronous state management logic, so that we can use those as points of reference for ensuring that new versions of our libraries work correctly going forward.\r\n\r\nPaging @gaearon , @acdlite , @bvaughn , @timdorr , @jimbolla , @cellog , @mweststrate, @peggyrayzis , and @jbaxleyiii for their thoughts and participation.\r\n\r\n",
  "closed_by": {
    "login": "gaearon",
    "id": 810438,
    "node_id": "MDQ6VXNlcjgxMDQzOA==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/810438?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gaearon",
    "html_url": "https://github.com/gaearon",
    "followers_url": "https://api.github.com/users/gaearon/followers",
    "following_url": "https://api.github.com/users/gaearon/following{/other_user}",
    "gists_url": "https://api.github.com/users/gaearon/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gaearon/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gaearon/subscriptions",
    "organizations_url": "https://api.github.com/users/gaearon/orgs",
    "repos_url": "https://api.github.com/users/gaearon/repos",
    "events_url": "https://api.github.com/users/gaearon/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gaearon/received_events",
    "type": "User",
    "site_admin": false
  }
}
