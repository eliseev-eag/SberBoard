{
  "url": "https://api.github.com/repos/facebook/react/issues/16073",
  "repository_url": "https://api.github.com/repos/facebook/react",
  "labels_url": "https://api.github.com/repos/facebook/react/issues/16073/labels{/name}",
  "comments_url": "https://api.github.com/repos/facebook/react/issues/16073/comments",
  "events_url": "https://api.github.com/repos/facebook/react/issues/16073/events",
  "html_url": "https://github.com/facebook/react/issues/16073",
  "id": 464890349,
  "node_id": "MDU6SXNzdWU0NjQ4OTAzNDk=",
  "number": 16073,
  "title": "Issues regarding resetting the initial state",
  "user": {
    "login": "fabiospampinato",
    "id": 1812093,
    "node_id": "MDQ6VXNlcjE4MTIwOTM=",
    "avatar_url": "https://avatars1.githubusercontent.com/u/1812093?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fabiospampinato",
    "html_url": "https://github.com/fabiospampinato",
    "followers_url": "https://api.github.com/users/fabiospampinato/followers",
    "following_url": "https://api.github.com/users/fabiospampinato/following{/other_user}",
    "gists_url": "https://api.github.com/users/fabiospampinato/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fabiospampinato/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fabiospampinato/subscriptions",
    "organizations_url": "https://api.github.com/users/fabiospampinato/orgs",
    "repos_url": "https://api.github.com/users/fabiospampinato/repos",
    "events_url": "https://api.github.com/users/fabiospampinato/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fabiospampinato/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 0,
  "created_at": "2019-07-06T21:03:26Z",
  "updated_at": "2019-07-06T21:27:19Z",
  "closed_at": null,
  "author_association": "NONE",
  "body": "I have the following hook:\r\n\r\n```jsx\r\nfunction usePromise ( promise ) {\r\n\r\n  let [result, setResult] = useState ({ loading: true });\r\n\r\n  useMemo ( () => {\r\n\r\n    result = { loading: true };\r\n    setResult ( result );\r\n\r\n    promise.then ( value => setResult ({ loading: false, value }) )\r\n           .catch ( error => setResult ({ loading: false, error }) );\r\n\r\n  }, [promise] );\r\n\r\n  return result;\r\n\r\n}\r\n```\r\n\r\nIt accepts a promise and returns an object that tells you if the promise did resolve/reject or if it did not settle yet. I think this is a fairly common pattern.\r\n\r\nFirst of all notice how I'm using `useMemo`, as we want to attach `then`/`catch` handlers only once.\r\n\r\nSecondly notice how inside `useMemo` I'm resetting the `result` object whenever the promise changes, as we don't want it to return the previous result object instead.\r\n\r\nI'm resetting the `result` object both permanently, via `setResult`, and temporarily, by assigning to it directly. I believe the direct assignment is necessary here because otherwise my component will immediately receive the previous `result` object instead of the new one.\r\n\r\nThere are multiple issues even with this fairly simple hook:\r\n\r\n### 1 - Inappropriate linter warning\r\n\r\nThe linter is complaining about assigning directly to `result` with the following message:\r\n\r\n```\r\nAssignments to the 'result' variable from inside React Hook useMemo will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useMemo.eslint(react-hooks/exhaustive-deps)\r\n```\r\n\r\nSince I'm also using `setResult` here this issue seems none existent, maybe this warning shouldn't be displayed in this situation?\r\n\r\n### 2 - Missing linter warning\r\n\r\nIf I don't update the `result` variable immediately by directly assigning to it my component will initially receive the wrong object, which is an error, and I think it will also be rendered twice, once with the wrong object, and a second time with the right one once `setResult` does its job.\r\n\r\nShouldn't in situations like this be a linter rule that _encourages_, instead of discourages, you to also update the value directly in order to avoid those issues?\r\n\r\n### 3 - Updating state while the component is unmounted\r\n\r\nI think my `usePromise` hook will eventually call `setResult` while the component is unmounted because the promise will eventually resolve/reject after the component has been unmounted.\r\n\r\nSo I'll have to update it to check if the component is still mounted, otherwise React will log an error about this.\r\n\r\nWhat's the point of this error? Why can't/shouldn't React itself just ignore my `setResult` call if the component is not mounted? Or at the very least why is React logging an error about this and not a warning?\r\n\r\nI find myself stumbling into this issue pretty often, perhaps a linter rule can be written about this?\r\n\r\n### 4 - Which hook to use?\r\n\r\nIf I'm understanding this correctly instead of `useMemo` I could have used `useEffect` or `useLayoutEffect` and have gotten _almost_ the same result, I say almost because:\r\n\r\n- `useMemo` calls the passed function immediately, which is want we want or the promise may throw an exception that we won't be able to catch.\r\n- `useLayoutEffect` would call the passed function at a later time, right before the browser is ready to render the frame, or at least I believe that's the case, but if I have 10 `useLayoutEffect` calls and the first one keeps the main thread busy for 1 minute are the other 9 always going to get executed before the browser paints?\r\n- `useEffect` will call the passed function at a point in time that's not very clear to me. (e.g. should it be equivalent to `componentDidMount` + `componentWillUnmount`? Or was it `componentWillMount` + `componentDidUnmount` or some other permutation?)\r\n\r\nThe fact that there are 3 built-in hooks that could be used for this, which may not reveal any error for a long time, is a bit confusing to me.\r\n\r\n### General feedback\r\n\r\nI've recently migrated an app of mine to hooks and this particular issue has bit me more than once already, I keep stumbling upon it. In general I'm having troubles writing reliable custom hooks and components.\r\n\r\n1. There's no linter rule that reminds me to also update the value provided by `useState` hooks immediately, in fact it seems the current one discourages it.\r\n2. I think my components have become harder to reason about sometimes: \r\n\t- If I call `setFoo` 10 times is my component going to render 10 times?\r\n\t- Will React re-render my component also if I pass `setFoo` the same exact value as before?\r\n\t- If I use `useState` 3 times, and call the related `set*` methods from inside 3 `useEffect` hooks, one for each, is my component going to render 4 times if the first `useEffect` block relies on and updates the value provided by the first `useState`, the second `useEffect` block relies on the value provided by the first `useState` call too and updates the second, and the third `useEffect` block relies on the value provided by the second `useState` call and updates the third? And shouldn't I try to minimize these renderings by updating those values via an assignment also? \r\n\t- I basically use `useEffect` by default, but some times I see a bit of flickering/glitches in the UI, I replace it with `useLayoutEffect` instead, the issue gets fixed, and I notice that I'm actually mutating the DOM or something inside the hook.\r\n\t\t- I find this to be quite error-prone for me, as sometimes it's not clear that I'm actually mutating the DOM (say I want to update the `scrollTop` property of an element or something), as the line that actually does that may be abstracted away by some other high-level API.\r\n\t\t- I also find the mere existence of 2 effect-related hooks confusing, I think I understand under which scenarios `useLayoutEffect` should be used, and that it's called before the browser paints the new frame, but then when is my `useEffect` hook called? Is it always called after `useLayoutEffect`? What would happen if I replaced all my `useEffect` calls with `useLayoutEffect` calls instead?\r\n3. Generally hooks seem like a very good abstraction to me, but writing custom ones seems too error prone to me. I'm pretty new to hooks overall, but I think I'm relatively experienced as a developer, but if even writing a relatively simple one, like the `usePromise` hook I posted, has so many pitfalls to be aware of maybe this is an issue? I realize this sounds a bit like blaming the language for the bugs I've introduced, but perhaps there's a way to make this process less error prone? i.e. new/improved linter rules, less ambiguity (`useEffect`/`useLayoutEffect`), clearer lifecycle (when is `useEffect` even called? are my components re-rendering an unexpected amount of times?), no need to update values directly (hypothetically maybe they should be proxies so that `set*` functions can update them immediately or something? I realize that proxies aren't polyfillable but there might be other ways around it), no need for specifying dependencies (the code might be statically analyzable at build-time most of the times).\r\n\r\nIn hindsight maybe this \"General feedback\" section is a bit off-topic, let me know if you guys want me to move that into a separate issue.\r\n\r\nSorry for the long issue, hopefully it's helpful.",
  "closed_by": null
}
