{
  "url": "https://api.github.com/repos/facebook/react/issues/14406",
  "repository_url": "https://api.github.com/repos/facebook/react",
  "labels_url": "https://api.github.com/repos/facebook/react/issues/14406/labels{/name}",
  "comments_url": "https://api.github.com/repos/facebook/react/issues/14406/comments",
  "events_url": "https://api.github.com/repos/facebook/react/issues/14406/events",
  "html_url": "https://github.com/facebook/react/issues/14406",
  "id": 388941436,
  "node_id": "MDU6SXNzdWUzODg5NDE0MzY=",
  "number": 14406,
  "title": "Inference of Hooks’ inputs",
  "user": {
    "login": "yuchi",
    "id": 646609,
    "node_id": "MDQ6VXNlcjY0NjYwOQ==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/646609?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/yuchi",
    "html_url": "https://github.com/yuchi",
    "followers_url": "https://api.github.com/users/yuchi/followers",
    "following_url": "https://api.github.com/users/yuchi/following{/other_user}",
    "gists_url": "https://api.github.com/users/yuchi/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/yuchi/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/yuchi/subscriptions",
    "organizations_url": "https://api.github.com/users/yuchi/orgs",
    "repos_url": "https://api.github.com/users/yuchi/repos",
    "events_url": "https://api.github.com/users/yuchi/events{/privacy}",
    "received_events_url": "https://api.github.com/users/yuchi/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1109410193,
      "node_id": "MDU6TGFiZWwxMTA5NDEwMTkz",
      "url": "https://api.github.com/repos/facebook/react/labels/Component:%20Hooks",
      "name": "Component: Hooks",
      "color": "c2f27b",
      "default": false
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2018-12-08T17:26:02Z",
  "updated_at": "2018-12-20T17:15:15Z",
  "closed_at": null,
  "author_association": "NONE",
  "body": "I open this issue ([as suggested by @gaearon on Twitter](https://twitter.com/dan_abramov/status/1070770594323554310)) to discuss how Hook’s inputs argument should be inferred.\r\n\r\n## Background\r\n\r\nThe current [Hooks API reference](https://reactjs.org/docs/hooks-reference.html) cites (emphasis mine):\r\n\r\n> The array of inputs is not passed as arguments to the function. Conceptually, though, that’s what they represent: every value referenced inside the function should also appear in the inputs array. **In the future, a sufficiently advanced compiler could create this array automatically.**\r\n\r\nCaptivated by this sentence (and the idea of bringing “the future” closer) I built [`hooks.macro`][hm], a Babel Macro which tries to do exactly this. That is, to infer the second argument to `useMemo`, `useCallback` and `use*Effect` hooks.\r\n\r\nThe tool trasform this:\r\n\r\n```js\r\nimport { useAutoMemo } from 'hooks.macro';\r\nfunction MyComponent({ propValue }) {\r\n  return useAutoMemo(() => propValue.split('').join('-'));\r\n  //     ---^^^^----                                    ^ no inputs\r\n}\r\n```\r\n\r\nTo this:\r\n\r\n```js\r\nfunction MyComponent({ propValue }) {\r\n  return React.useMemo(() => propValue.split('').join('-'), [propValue]);\r\n  //     ^---^ ^-----^                                       ^-------^\r\n}\r\n```\r\n\r\nIn the process of designing the constraints of that tool, I realized there are more than a few open questions, whose answers can be found only with guidance from the core React team and a broader discussion with the community.\r\n\r\n## Rationale\r\n\r\nWhy should we bother with this topic? The reasons that motivated me in implementing `hooks.macro` were the following.\r\n\r\n1. Failing to populate the inputs array correctly has sad consequences:\r\n\r\n   1. too wide, and it will invalidate the use of memoization itself, and/or bring potential perf issues;\r\n\r\n   2. too narrow, and bugs can be tricky to identify (IMHO unit tests are not viable to avoid this: you need to test _changes_, not just different possible _values_;)\r\n\r\n   3. bugs caused by having non local values are potentially non deterministic.\r\n\r\n2. Keeping the inputs array updated is important, but it’s a matter of discipline:\r\n\r\n   1. when I change the “body” of the hook I need to check it;\r\n\r\n   2. when I change the semantics of a used valued I need to verify if I need to include it (e.g. when it was a constant and now a prop);\r\n\r\n   3. not introducing bugs during merge conflicts is matter of even _higher_ discipline (since usually inputs will fit in a single line, you probably need to edit the line to solve the conflict).\r\n\r\n3. By removing the burden of adding the inputs array, we reduce the mental overhead of using the memoizing hooks (namely `useMemo` and `useCallback`). This let us:\r\n\r\n   1. make following the best practices easier,\r\n\r\n   2. encourage the use of memoization in unexpected places (such as directly inside the final returning JSX of a component).\r\n\r\n4. Nothing is stopping me from shooting my own feet with obvious errors (such as passing the result of a non-memoized array literal ad an input). If a stable enough approach is found, this could be even solved automatically by memoizing all necessary inputs too.\r\n\r\n5. It’s an error-prone and boring practice that can be automated away.\r\n\r\n## Current implementation\r\n\r\n(Straight from [`hooks.macro`’s README][hm])\r\n\r\n#### Features\r\n\r\n1. Extracts all references used, and adds them to the _inputs_ array.\r\n\r\n2. Favors **strict correctness over performance**, but uses **safe optimizations:**\r\n\r\n   1. skips constants and useless inputs;\r\n\r\n   2. traverses all functions called or referenced, and appends _their_ dependencies too, removing the need for unnecessary `useCallback` hooks.\r\n\r\n#### Constraints\r\n\r\n1. Only variables created in the scope of the component body are automatically trapped as inputs.\r\n\r\n2. Only variables, and not properties’ access, are trapped. This means that if you use `obj.prop` only `[obj]` will become part of the memoization invalidation keys. This is a problem for refs, and will be addressed specifically in a future release.\r\n\r\n   You can work around this limitation by creating a variable which holds the current value, such as `const { current } = ref`.\r\n\r\n3. Currently there’s no way to add additional keys for more fine grained cache invalidation. Could be an important escape hatch when you do nasty things, but in that case I’d prefer to use `useMemo`/`useCallback` directly.\r\n\r\n4. Only locally defined functions declarations and explicit function expressions (`let x = () => {}`) are traversed for indirect dependencies — all other function calls (such as `xxx()`) are treated as normal input dependencies and appended too. This is unnecessary (but not harmful) for setters coming from `useState`, and not an issue at all if the function is the result of `useCallback` or `useAutoCallback`.\r\n\r\n## Questions\r\n\r\nAs I said before I have few open questions for the core React team, but I’m sure the whole community will be impactful in the discussion.\r\n\r\n1. What were/are the requirements of the «sufficiently advanced compiler» you envision? Is the current approach of `hooks.macro` aligned with those?\r\n\r\n2. Using a broader approach, Flow/TypeScript hints could give an incredible amount of precision not available on the pure Babel pipeline. I feel pre-pack can help here too (we could help pre-pack do its thing actually) but I’m not sure how.\r\n\r\n3. Are users potentially scared by the amount of black magic involved? I _tried_ to follow the Hooks lead by having very clear, very understandable rules. Is this _enough_?\r\n\r\n4. The auto-closure feature of `useMemo` (you don’t need an arrow function) has received the most negative feedback in the small discussions I had online. Yet I personally find the most interesting hook of this library, since adds so little overhead I can throw it any time I need… potentially abusing it eventually (so, points against it?)\r\n\r\n5. I personally prefer to have a different API that makes it clear that those are not standard hooks without \"inputs\". A Babel plugin that transform all hooks without an explicit inputs array seems silly and scary — you get used to _not_ passing them and you don't have the API signaling you that you need to.\r\n\r\n6. Since this is a specialized form of lambda-lifting, are you willing to add some advanced hooks (with one of your lovely silly prefixes such as `DONT_USE_`) that pass the inputs as arguments to creator/effect function? This open some interesting perf optimization opportunities by hoisting functions higher up.\r\n\r\n[hm]: https://github.com/yuchi/hooks.macro\r\n",
  "closed_by": null
}
