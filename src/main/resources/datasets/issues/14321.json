{
  "url": "https://api.github.com/repos/facebook/react/issues/14321",
  "repository_url": "https://api.github.com/repos/facebook/react",
  "labels_url": "https://api.github.com/repos/facebook/react/issues/14321/labels{/name}",
  "comments_url": "https://api.github.com/repos/facebook/react/issues/14321/comments",
  "events_url": "https://api.github.com/repos/facebook/react/issues/14321/events",
  "html_url": "https://github.com/facebook/react/issues/14321",
  "id": 384021246,
  "node_id": "MDU6SXNzdWUzODQwMjEyNDY=",
  "number": 14321,
  "title": "getDerivedStateFromProps is user-hostile",
  "user": {
    "login": "loganb",
    "id": 17287,
    "node_id": "MDQ6VXNlcjE3Mjg3",
    "avatar_url": "https://avatars0.githubusercontent.com/u/17287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/loganb",
    "html_url": "https://github.com/loganb",
    "followers_url": "https://api.github.com/users/loganb/followers",
    "following_url": "https://api.github.com/users/loganb/following{/other_user}",
    "gists_url": "https://api.github.com/users/loganb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/loganb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/loganb/subscriptions",
    "organizations_url": "https://api.github.com/users/loganb/orgs",
    "repos_url": "https://api.github.com/users/loganb/repos",
    "events_url": "https://api.github.com/users/loganb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/loganb/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 40929155,
      "node_id": "MDU6TGFiZWw0MDkyOTE1NQ==",
      "url": "https://api.github.com/repos/facebook/react/labels/Type:%20Question",
      "name": "Type: Question",
      "color": "cc317c",
      "default": false
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 3,
  "created_at": "2018-11-24T20:56:14Z",
  "updated_at": "2018-12-14T01:47:46Z",
  "closed_at": null,
  "author_association": "NONE",
  "body": "So I think `getDerivedStateFromProps` as designed turns out to be user-hostile. The short summary is that it makes the pattern described in the docs, https://reactjs.org/docs/higher-order-components.html#use-hocs-for-cross-cutting-concerns, impossible for non-trivial cases. \r\n\r\nImagine implementing an HOC that listens to change events on a DataSource, but where a simple shallowEqual() on the resultant state isn't sufficient to prevent rendering. I.e., what if you need more complex logic to determine if new data from the DataSource should be applied? \r\n\r\nIn my case, I have a DataSource that doesn't guarantee that it will give out objects of the same identity, so a `===` check will always return false and cause a re-render. BUT, I can do a little bookkeeping on the side and determine whether the data is actually new and should therefore be loaded into state. \r\n\r\nThis leads to some problems: \r\n1) Because `getDerivedStateFromProps` is static, it's not possible to store some internal bookkeeping data on the Component instance that gets used to determine whether to query the DataSource. Worst case, this bookkeeping information could be stuffed in the state object, but that's unnecessarily constraining and a bit ugly from a code organization perspective. \r\n2) More importantly, it's not possible to determine why `getDerivedStateFromProps` is being called. Is it because of a props change? Or is it because of a \"change\" event firing on the `DataSource`? \r\n\r\nThis matters because if props have changed, data must be fetched and the Component re-rendered unconditionally, but if the props haven't changed, then it's possible all the data loaded is the same as last time, and so `render()` can be skipped. \r\n\r\nHere's an example using the deprecated API that's no longer possible, lightly edited from the HOC example I mention above: \r\n```\r\nfunction withDataLoading(Component, DataSource, getDataFunc) {\r\n\r\n  return class extends React.PureComponent {\r\n    componentDidMount() {\r\n      // Subscribe to changes\r\n      DataSource.addChangeListener(this.handleChange);\r\n    }\r\n  \r\n    componentWillUnmount() {\r\n      // Clean up listener\r\n      DataSource.removeChangeListener(this.handleChange);\r\n    }\r\n\r\n    componentWillReceiveProps(props) {\r\n      //Unconditionally update state and rerender since the props changed\r\n      const possiblyNewData = getDataFunc(DataSource, props, this)\r\n      this.setState(possiblyNewData);\r\n      //Remember some metadata about what we fetched for next time\r\n      this.bookkeeping = DataSource.bookkeepingData();\r\n    }\r\n  \r\n    handleChange() {\r\n      // Update component state whenever the data source changes\r\n      const possiblyNewData = getDataFunc(DataSource, this.props, this)\r\n      if(DataSource.didIFetchNewData(this.bookkeeping)) {\r\n        //The DataSource had updated data in it, so rerender\r\n        this.setState(possiblyNewData);\r\n        //Remember some metadata about what we fetched for next time\r\n        this.bookkeeping = DataSource.bookkeepingData();\r\n      } else {\r\n        //No new data was fetched, so don't update State and don't rerender\r\n        //Do nothingâ€¦\r\n      }\r\n    }\r\n\r\n    render() {\r\n      <Component data={this.state}/>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nNotice that the behavior is different between `componentWillReceiveProps` and `handleChange`. There's no way to make that distinction with the new API. ",
  "closed_by": null
}
