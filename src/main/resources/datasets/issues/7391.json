{
  "url": "https://api.github.com/repos/facebook/react/issues/7391",
  "repository_url": "https://api.github.com/repos/facebook/react",
  "labels_url": "https://api.github.com/repos/facebook/react/issues/7391/labels{/name}",
  "comments_url": "https://api.github.com/repos/facebook/react/issues/7391/comments",
  "events_url": "https://api.github.com/repos/facebook/react/issues/7391/events",
  "html_url": "https://github.com/facebook/react/issues/7391",
  "id": 168670862,
  "node_id": "MDU6SXNzdWUxNjg2NzA4NjI=",
  "number": 7391,
  "title": "Reusable Components: we probably are doing it wrong",
  "user": {
    "login": "hnordt",
    "id": 1625399,
    "node_id": "MDQ6VXNlcjE2MjUzOTk=",
    "avatar_url": "https://avatars2.githubusercontent.com/u/1625399?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hnordt",
    "html_url": "https://github.com/hnordt",
    "followers_url": "https://api.github.com/users/hnordt/followers",
    "following_url": "https://api.github.com/users/hnordt/following{/other_user}",
    "gists_url": "https://api.github.com/users/hnordt/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hnordt/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hnordt/subscriptions",
    "organizations_url": "https://api.github.com/users/hnordt/orgs",
    "repos_url": "https://api.github.com/users/hnordt/repos",
    "events_url": "https://api.github.com/users/hnordt/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hnordt/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 9,
  "created_at": "2016-08-01T15:16:25Z",
  "updated_at": "2016-08-01T16:58:20Z",
  "closed_at": "2016-08-01T15:49:56Z",
  "author_association": "CONTRIBUTOR",
  "body": "I have been using React for business projects since 2015. I built 2 large, 1 medium and many small apps.\n\nOne of my dreams is to create reusable components that can be shared across projects and still support highly customization even if the CSS framework changes; I mean, I want to support Bootstrap, Foundation, Semantic UI, raw styles and other frameworks that I don't know.\n\nTo do it I discovered that we should be highly explicit and shouldn't make styling assumptions. For example:\n\n``` js\n// BAD\nfunction Button({ className, type, style, children, ...other }) {\n  return (\n    <button {...other} className={`btn btn-${type} ${className || ''}`} style={style}>\n      {children}\n    </button>\n  )\n}\n```\n\nPS: I'm not trying to say that my approach is the best and others are bad, I'm just sharing how I fixed my problem, so others can try the same approach and see if it's a fit for other projects.\n\n**What's the problem?**\n1. We are passing `other`; if we are building a reusable `Button` API we should create a formal API, `other` is too general, it's the same as defining a `Person` database model and allowing the consumer to pass anything; it's cool for small projects or prototypes, but if it's a reusable component, you need to make it more formal.\n2. We are assuming that Bootstrap will be used when we pass `btn` and `btn-x` as classes. What about Foundation? What about Semantic UI? What about users that don't use a CSS framework at all? If it's a reusable component, it should support many styling frameworks or techniques, because every project is different.\n\n**How to solve?**\n1. Make a formal API, if it's too early to create a formal API, then your reusable component shouldn't be `>= v1`, I mean, you are still experimenting and looking for a good API.\n2. Your reusable component shouldn't define classes or styles at all, except for styles that you know that will never change for the type of component you are building (.e.g. a dropdown or autocomplete popup always need some styles like `position`, `top`, `left`, etc, in this case it's not a problem, because these styles define how your component should behave and will never change if we change our CSS framework or aesthetics styles).\n\n**A Real World Example**\n\n``` js\n// When you pass props like `getClassName` and `getStyle`\n// you delegate the job to the consumer because the consumer\n// is the one that knows your app domain logic/styles\n//\n// Doing that way makes your reusable code a lot cleaner and easier to reason about\n// The job of your reusable code is just define a formal API\n// A formal API is an API that you know that is really good and you can use it\n// with confidence\n//\n// It's like the Redux concept: actions and reducers implementations are your job\n// Redux just tell you to use actions and reducers because it's the formal API\n// and they know that's really good\n//\n// For a `Button` we know that it always have some types, so we formalize it\n// then the consumer can use it to apply specific styles and classes\n//\nfunction ReusableButton({ type, getClassName, getStyle, children }) {\n  return (\n    <button className={getClassName(type)} style={getStyle(type)}>\n      {children}\n    </button>\n  )\n}\n\nReusableButton.propTypes = {\n  type: PropTypes.oneOf(['primary', 'secondary', 'success', 'warning', 'danger']).isRequired,\n  getClassName: PropTypes.func,\n  getStyle: PropTypes.func,\n  children: PropTypes.node.isRequired\n}\n\nReusableButton.defaultProps = {\n  getClassName: () => null,\n  getStyle: () => null\n}\n\n// MyAppButton.js\n\n// If in the future we need to change our CSS framework\n// Probably we'll need to change only this function\nfunction getClassName(type) {\n  return `btn btn-${type}`;\n}\n\nfunction getStyle(type) {\n  if (type === 'danger') {\n    return { fontSize: 20 };\n  }\n  return null;\n}\n\nfunction MyAppButton({ type, children }) {\n  return (\n    <ReusableButton type={type} getClassName={getClassName} getStyle={getStyle}>\n      {children}\n    </ReusableButton>\n  )\n}\n```\n\n**Advantages**\n\nAs it's a simple example, you probably won't see any advantages. But I'll try to list some:\n1. Creating a formal API helps you thinking about how to apply styles in the next project, as `Button` defines some types that every app needs, you don't need to think about possible styles a `Button` have, you just use it\n2. For every project you'll use the same API, when you back to the project weeks or months later, you'll know how to use it\n3. Pulling fixes is easy as `npm update`\n4. Upgrading is easy as `npm install my-reusable-component@latest` and then updating just one file\n5. You can build a platform of `Buttons` on top of `ReusableButton`, e.g., `BootstrapButton`, `FoundationButton`, `SemanticButton`, etc; instead trying to cover every use case inside a `Button`, you use the power of composability\n",
  "closed_by": {
    "login": "hnordt",
    "id": 1625399,
    "node_id": "MDQ6VXNlcjE2MjUzOTk=",
    "avatar_url": "https://avatars2.githubusercontent.com/u/1625399?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hnordt",
    "html_url": "https://github.com/hnordt",
    "followers_url": "https://api.github.com/users/hnordt/followers",
    "following_url": "https://api.github.com/users/hnordt/following{/other_user}",
    "gists_url": "https://api.github.com/users/hnordt/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hnordt/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hnordt/subscriptions",
    "organizations_url": "https://api.github.com/users/hnordt/orgs",
    "repos_url": "https://api.github.com/users/hnordt/repos",
    "events_url": "https://api.github.com/users/hnordt/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hnordt/received_events",
    "type": "User",
    "site_admin": false
  }
}
