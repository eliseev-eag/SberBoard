{
  "url": "https://api.github.com/repos/facebook/react/issues/16299",
  "repository_url": "https://api.github.com/repos/facebook/react",
  "labels_url": "https://api.github.com/repos/facebook/react/issues/16299/labels{/name}",
  "comments_url": "https://api.github.com/repos/facebook/react/issues/16299/comments",
  "events_url": "https://api.github.com/repos/facebook/react/issues/16299/events",
  "html_url": "https://github.com/facebook/react/issues/16299",
  "id": 477153300,
  "node_id": "MDU6SXNzdWU0NzcxNTMzMDA=",
  "number": 16299,
  "title": "[Feature Request] Alternative to service-locator pattern in React",
  "user": {
    "login": "alshdavid",
    "id": 12656294,
    "node_id": "MDQ6VXNlcjEyNjU2Mjk0",
    "avatar_url": "https://avatars0.githubusercontent.com/u/12656294?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alshdavid",
    "html_url": "https://github.com/alshdavid",
    "followers_url": "https://api.github.com/users/alshdavid/followers",
    "following_url": "https://api.github.com/users/alshdavid/following{/other_user}",
    "gists_url": "https://api.github.com/users/alshdavid/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alshdavid/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alshdavid/subscriptions",
    "organizations_url": "https://api.github.com/users/alshdavid/orgs",
    "repos_url": "https://api.github.com/users/alshdavid/repos",
    "events_url": "https://api.github.com/users/alshdavid/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alshdavid/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2019-08-06T03:41:45Z",
  "updated_at": "2019-08-07T02:27:29Z",
  "closed_at": "2019-08-07T01:55:42Z",
  "author_association": "NONE",
  "body": "_**I'm sorry about the long post**_\r\n \r\n### The problem:\r\n \r\nAchieving dependency inversion and inversion of control within React is challenging because existing solutions rely on the service locator pattern to transport dependencies from their providers into their consumers.\r\n \r\nThis results in strong coupling of components to their surrounding implementations, decreasing testability, increasing boilerplate and discouraging developers from creating abstractions. \r\n \r\nA common pre-context solution to dependency injection is manually wrapping all used components with “provider” functions. An example of this is using functions like `withTheme()` or `connect()`.\r\n \r\n```jsx\r\nimport { withItems } from '../items'\r\n \r\nexport const Hello ={ items = [] }) => {\r\n  return <div>\r\n    { items.map(item => <div>{item}</div>) }\r\n  </div>\r\n}\r\n \r\nexport const InjectedHello = withItems(Hello)\r\n```\r\n \r\nWrapping components like this creates silos of troublesome testability and due to it’s unergonomic nature, discourages decoupling components from the surrounding application implementation. \r\n \r\nIn order to create decoupled component packages (say a UI library that lives in npm), the author must create components which receive all dependencies via props. In order to satisfy these dependencies, a consumer must import the library and re-wrap/re-export every component, injecting their dependencies from a service locator. \r\n \r\n```javascript\r\nimport { Button } from 'generic-ui'\r\nimport { withTheme } from '../somewhere' // service locator\r\n \r\nexport const ThemedButton = withTheme(Button)\r\n```\r\n \r\nA consumer must also exclude the wrapped “aware” components from unit tests as it’s impractical to test them in a sensible way.\r\n \r\nhttps://en.wikipedia.org/wiki/Service_locator_pattern\r\n \r\nAn example of a basic service locator in JS is here\r\nhttps://stackblitz.com/edit/js-6qzkak\r\n \r\nAn example of a service locator with React is here\r\nhttps://stackblitz.com/edit/react-tdt624\r\n \r\n \r\n### What about context?\r\n \r\nContext provides a much more ergonomic solution. It still relies on the same service-locator pattern, but it’s ease of use makes it more approachable.\r\n \r\nBoiled down, what context simply provides is a vehicle for dependencies to tunnel from their creator to their consumer under the floorboards of the library. It’s essentially an alternative to drilling props from the top level to the embedded components.\r\n \r\nReceiving the theme from a context `const theme = useContext(ThemeContext)` also relies on the context being supplied by a concrete location.\r\n \r\nIf you imagine a simple, generic concept like a store using the Flux architecture; utilities like Redux, MobX. These third party libraries *must* have “React” as a peerDependency. The only alternative is supplying a \"react-connected\" variant of their library.\r\n \r\nFor this reason we have the two packages, ‘redux’ and ‘react-redux’. While the latter does provide some convenience utilities, it's use is not optional. It _*must*_ exist along-side the original implementation.\r\n \r\nSo here is a demonstration of how React enforces coupling by not providing an effective means to handle inversion of control. Below I have a factory function which creates a flux store:\r\n \r\n```javascript\r\nexport const createPostStore = () => {\r\n  const posts = createStateEmitter([])\r\n \r\n  const getValue = () => posts.getValue()\r\n \r\n  const add = (post) => {\r\n    posts.setState([\r\n      { title: post, id: randomString() },\r\n      ...getValue()\r\n    ])\r\n  }\r\n \r\n  return {\r\n    posts,\r\n    getValue,\r\n    add\r\n  }\r\n}\r\n```\r\nIt is consumed like you would consume Redux\r\n \r\n```javascript\r\nconst store = createPostStore()\r\nstore.subscribe(posts => console.log(posts))\r\nstore.add('New Post!')\r\n```\r\nThis unit has no external dependencies and can be consumed within React to hold state and trigger re-renders. It is easily tested and can be put in npm without a hard dependency on React.\r\n \r\nexample:\r\nhttps://stackblitz.com/edit/react-gnj8ba\r\n \r\nThis example shows \"prop drilling\" to get the store into the component. This is ideal from an IoC standpoint, but impractical as with many layers of embedded components, you'll pass dependencies down a long tree and it's difficult to maintain.\r\n \r\nOf course, I can simply export a context from my package, but I want to avoid a hard dependency on React as it's not really a concern of the library.\r\n \r\nAnother solution to this problem is to have a shared, global context, where there is a contract that components will consume it and extract their required dependencies from there.\r\n \r\nhttps://stackblitz.com/edit/react-fz6ue8\r\n \r\nThe challenge here is that I can't expect Bootstrap, Material, or anyone on the internet to `npm install global-context` and have it be the de facto \"shared context\" which allows for IoC/agnosticism in component implementations.\r\n \r\nThe last solution is to make two packages, the package itself and a second package that has a hard dependency on React and exposes a context (Just like Redux and React Redux).\r\n \r\n### Ok, so what's the solution?\r\n \r\nHard to say. React applications often have many layers of components so any solution must involve supplying embedded components their dependencies in a way that scopes their \"providing\" to the current instance of React.\r\n \r\nSomething like a PropProvider, which supplies props to all embedded components might be a solution. It's opt-in making it minimally invasive. It changes nothing for the existing public React API and simply adds another, more flexible, option to a problem you'd normally `useTheme()` to solve.\r\n \r\n```jsx\r\n<PropProvider values={{ everyone: 'gets this' }}>\r\n    <MyComponent />\r\n</PropProvider>\r\n```\r\n \r\nThe problem with this is naming clashes. If you're a library vendor, you'll need to be creative to avoid clashes. The custom element specification stipulates that you must hyphenate your element names to avoid, or reduce the instances of clashes. Maybe that's a solution?\r\n \r\nAnother option is using getter functions, where key names are nearly impossible to clash and a function knows where to look.\r\n \r\n```javascript\r\nconst MyComponent = (props) => {\r\n    const theme = getTheme(props)\r\n}\r\n```\r\n \r\nMaybe an official static context for the react instance?\r\n \r\n```jsx\r\nReactDOM.render(\r\n    <App/>,\r\n    element,\r\n    { everyone: 'gets this' }\r\n)\r\n```\r\n",
  "closed_by": {
    "login": "alshdavid",
    "id": 12656294,
    "node_id": "MDQ6VXNlcjEyNjU2Mjk0",
    "avatar_url": "https://avatars0.githubusercontent.com/u/12656294?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alshdavid",
    "html_url": "https://github.com/alshdavid",
    "followers_url": "https://api.github.com/users/alshdavid/followers",
    "following_url": "https://api.github.com/users/alshdavid/following{/other_user}",
    "gists_url": "https://api.github.com/users/alshdavid/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alshdavid/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alshdavid/subscriptions",
    "organizations_url": "https://api.github.com/users/alshdavid/orgs",
    "repos_url": "https://api.github.com/users/alshdavid/repos",
    "events_url": "https://api.github.com/users/alshdavid/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alshdavid/received_events",
    "type": "User",
    "site_admin": false
  }
}
