{
  "url": "https://api.github.com/repos/facebook/react/issues/14514",
  "repository_url": "https://api.github.com/repos/facebook/react",
  "labels_url": "https://api.github.com/repos/facebook/react/issues/14514/labels{/name}",
  "comments_url": "https://api.github.com/repos/facebook/react/issues/14514/comments",
  "events_url": "https://api.github.com/repos/facebook/react/issues/14514/events",
  "html_url": "https://github.com/facebook/react/issues/14514",
  "id": 395105006,
  "node_id": "MDU6SXNzdWUzOTUxMDUwMDY=",
  "number": 14514,
  "title": "Proposal: Add top level useMount/useUnmount to improve scannability/prevent fragmentation",
  "user": {
    "login": "scottmas",
    "id": 2257337,
    "node_id": "MDQ6VXNlcjIyNTczMzc=",
    "avatar_url": "https://avatars2.githubusercontent.com/u/2257337?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/scottmas",
    "html_url": "https://github.com/scottmas",
    "followers_url": "https://api.github.com/users/scottmas/followers",
    "following_url": "https://api.github.com/users/scottmas/following{/other_user}",
    "gists_url": "https://api.github.com/users/scottmas/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/scottmas/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/scottmas/subscriptions",
    "organizations_url": "https://api.github.com/users/scottmas/orgs",
    "repos_url": "https://api.github.com/users/scottmas/repos",
    "events_url": "https://api.github.com/users/scottmas/events{/privacy}",
    "received_events_url": "https://api.github.com/users/scottmas/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 8,
  "created_at": "2019-01-01T19:03:38Z",
  "updated_at": "2019-01-02T22:33:56Z",
  "closed_at": "2019-01-02T21:02:19Z",
  "author_association": "NONE",
  "body": "This is a feature request.\r\n\r\nThe current hooks API provides everything that is necessary to create sophisticated and elegant applications. However, the current api is something of a step backwards in terms of scannability - e.g. Understanding when various code will execute in the component's lifecycle. \r\n\r\nAs a trivial example, suppose I simply want to log some information everytime a component unmounts for some analytics purpose. That's it. Right now, the simple implementation is:\r\n\r\n```javascript\r\nuseEffect(() => {\r\n  return () => {\r\n    fetch('some-analytics-api.com');\r\n  }\r\n}, [])\r\n```\r\n\r\nThere's no issue with whether this code works. Clearly it does. However, when developers are scanning the code base littered with multiple `useEffect` invocations, all of which have different memoization arrays, it takes a second to realize what this code is supposed to be doing - _\"Hmm, I see we're sending some analytics request. Okay, it's a callback returning a callback, so it's a disposer function. Oh, and there's an empty array as the final parameter, so the disposer only fires when the component unmounts\"_. That fraction of a second to make that determination is just a bit too long in my opinion. With a new topLevel API `useUnmount` it is grokkable almost instantly:\r\n\r\n```javascript\r\nuseUnmount(() => {\r\n  fetch('some-analytics-api.com');\r\n})\r\n```\r\n\r\nThis proposal is to add a set of top level primitives that map more directly to the API's that developers are already familiar with and that correspond more closely to the lifecycle events developers think about when reasoning about application flow. The proposed top level hooks include `useMount`, `useUnmount` with either an optional flag to run inside a layout effect, or else two additional top level hooks `useLayoutMount`, `useLayoutUnmount`. \r\n\r\nA likely concern with this proposal is that it will  unnecessarily bloat the top level API. The reasoning goes: _Why add to the top level API convenience wrappers that can be coded in userland?_ It's a legitimate concern. In this case however, I argue that the use case is _so_ common that the benefits outweigh the cost. To borrow an analogy, developers have been able to perform `Array.map` since the invention of Javascript, but once it's usefulness and ubiquity was established, it was added to the language proper. I'm making this same argument for `useMount` and `useUnmount`. \r\n\r\nAs evidence that these convenience wrappers are going to become extremely popular, simple Github searches for uses of `useUnmount` and `useMount` (https://github.com/search?q=useUnmount+react&type=Code and https://github.com/search?q=useMount+react&type=Code) return some 100+ repos already declaring their own convenience wrappers for these effects. Unless added to core, this number will expand drastically once hooks leave alpha. Clearly developers want these convenience wrappers, and will either write them themselves or import an external library (lodash for React? Please no...) that does it for them. \r\n\r\nAnother likely concern with this proposal is that developers will use these syntactic sugar functions to write less optimized and self contained code. To borrow an example from the documentation, the fear is that instead of:\r\n\r\n```javascript\r\nuseEffect(() => {\r\n  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\r\n  // Specify how to clean up after this effect:\r\n  return function cleanup() {\r\n    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\r\n  };\r\n}, []);\r\n```\r\n\r\nDevs will inefficiently do: \r\n```javascript\r\nuseMount(() => {\r\n  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\r\n})\r\n\r\nuseUnmount(() => {\r\n  ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);      \r\n})\r\n```\r\nFrom a practical performance perspective though, these two implementations are basically identical and not worth worrying about. Function definitions and invocations are cheap in modern javascript. As to the issue of the code being less self contained, in most instances I believe that won't be a problem since developers will simply extract the logic into a self contained custom hook like `useFriendStatus` that encapsulates all the logic into an atomic piece. \r\n\r\nOne small additional benefit: With `useMount`/`useUnmount` being in React Core, instead of dozens of different snowflake implementations, there may feasibly be future optimizations on the hooks that React core will then be able implement on an ecosystem wide basis. \r\n\r\nSo in summary, it seems to me that React can either fight the inevitable or embrace it. \r\n\r\nAs a purely stylistic (for now at least) question, there's no real right or wrong answer to this proposal and barring extremely strong technical reasons against the proposal, I'm not sure how it can be discussed cooly and objectively. Maybe a developer survey? ",
  "closed_by": {
    "login": "gaearon",
    "id": 810438,
    "node_id": "MDQ6VXNlcjgxMDQzOA==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/810438?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gaearon",
    "html_url": "https://github.com/gaearon",
    "followers_url": "https://api.github.com/users/gaearon/followers",
    "following_url": "https://api.github.com/users/gaearon/following{/other_user}",
    "gists_url": "https://api.github.com/users/gaearon/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gaearon/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gaearon/subscriptions",
    "organizations_url": "https://api.github.com/users/gaearon/orgs",
    "repos_url": "https://api.github.com/users/gaearon/repos",
    "events_url": "https://api.github.com/users/gaearon/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gaearon/received_events",
    "type": "User",
    "site_admin": false
  }
}
