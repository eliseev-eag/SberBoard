{
  "url": "https://api.github.com/repos/facebook/react/issues/16474",
  "repository_url": "https://api.github.com/repos/facebook/react",
  "labels_url": "https://api.github.com/repos/facebook/react/issues/16474/labels{/name}",
  "comments_url": "https://api.github.com/repos/facebook/react/issues/16474/comments",
  "events_url": "https://api.github.com/repos/facebook/react/issues/16474/events",
  "html_url": "https://github.com/facebook/react/issues/16474",
  "id": 482545095,
  "node_id": "MDU6SXNzdWU0ODI1NDUwOTU=",
  "number": 16474,
  "title": "DevTools: Named hooks",
  "user": {
    "login": "bvaughn",
    "id": 29597,
    "node_id": "MDQ6VXNlcjI5NTk3",
    "avatar_url": "https://avatars0.githubusercontent.com/u/29597?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bvaughn",
    "html_url": "https://github.com/bvaughn",
    "followers_url": "https://api.github.com/users/bvaughn/followers",
    "following_url": "https://api.github.com/users/bvaughn/following{/other_user}",
    "gists_url": "https://api.github.com/users/bvaughn/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bvaughn/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bvaughn/subscriptions",
    "organizations_url": "https://api.github.com/users/bvaughn/orgs",
    "repos_url": "https://api.github.com/users/bvaughn/repos",
    "events_url": "https://api.github.com/users/bvaughn/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bvaughn/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 710573595,
      "node_id": "MDU6TGFiZWw3MTA1NzM1OTU=",
      "url": "https://api.github.com/repos/facebook/react/labels/Component:%20Developer%20Tools",
      "name": "Component: Developer Tools",
      "color": "fbca04",
      "default": false
    },
    {
      "id": 710375792,
      "node_id": "MDU6TGFiZWw3MTAzNzU3OTI=",
      "url": "https://api.github.com/repos/facebook/react/labels/Type:%20Discussion",
      "name": "Type: Discussion",
      "color": "fef2c0",
      "default": false
    },
    {
      "id": 40929153,
      "node_id": "MDU6TGFiZWw0MDkyOTE1Mw==",
      "url": "https://api.github.com/repos/facebook/react/labels/Type:%20Enhancement",
      "name": "Type: Enhancement",
      "color": "84b6eb",
      "default": false
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2019-08-19T21:50:31Z",
  "updated_at": "2019-10-15T17:26:02Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "body": "## The problem\r\n\r\nOne common piece of feedback about DevTools hooks integration is that hooks have no name and can be confusing. Consider the following example:\r\n```js\r\nfunction useSomeCustomHook() {\r\n  const [foo, setFoo] = useState(true);\r\n  const [bar, setBar] = useState(false);\r\n\r\n  // ...\r\n}\r\n\r\nfunction Example() {\r\n  const baz = useSomeCustomHook();\r\n\r\n  // ...\r\n}\r\n```\r\n\r\nCurrently in DevTools the above component would be displayed as follows:\r\n```\r\nSomeCustomHook:\r\n  State: true\r\n  State: false\r\n```\r\n\r\nThis information isn't as rich as we would prefer. ☹️\r\n\r\nThe next question is often: \"can you use the name of the variable the hook return value is assigned to?\" but this is tricky because DevTools doesn't actually have any way to access that variable. (Even if DevTools has a handle on the `Example` function above, how would it access the `useSomeCustomHook` function?)\r\n\r\n## The proposal\r\n\r\nThe solution to this would be some form of user-defined metadata (preferably generated by a code transform). Building on the precedent of the `useDebugValue` hook (https://github.com/facebook/react/pull/14559), we might introduce a new no-op hook e.g. `useDebugName`.\r\n\r\nThe above example could make use of this hook like so:\r\n```js\r\nfunction useSomeCustomHook() {\r\n  const [foo, setFoo] = useState(true);\r\n  useDebugName(\"foo\"); // injected by Babel transform\r\n  const [bar, setBar] = useState(false);\r\n  useDebugName(\"bar\"); // injected by Babel transform\r\n\r\n  // ...\r\n}\r\n\r\nfunction Example() {\r\n  const baz = useSomeCustomHook();\r\n\r\n  // ...\r\n}\r\n```\r\n\r\nDevTools could then display something like:\r\n```\r\nSomeCustomHook:\r\n  State (foo): true\r\n  State (bar): true\r\n```\r\n\r\n## Implementation details\r\n\r\nThe new `useDebugName` hook might be a noop hook provided by React (similar to `useDebugValue`) _or_ it could even be an export from the (soon to be released [`react-debug-hooks` package](https://github.com/facebook/react/blob/master/packages/react-debug-tools/)). The key concerns would be that:\r\n1. It has no effect (and adds no overhead) when DevTools is not present.\r\n2. Not calling it at all (or only calling it for _some_ hooks) should not break or corrupt anything.\r\n\r\nDevTools could override the no-op `useDebugName` implementation before inspecting a component and automatically associate the provided name with the most recently called native hook.\r\n\r\nFor example, the following code should only result in one named hook (the second `useState` call).\r\n```js\r\nconst [foo, setFoo] = useState(true);\r\nconst [bar, setBar] = useState(false);\r\nuseDebugName(\"bar\"); // injected by Babel transform\r\nconst [baz, setBaz] = useState(true);\r\n```\r\n\r\nBeing able to support sparse name metadata would be important for third party code (that might not be transformed to supply the metadata).\r\n\r\nA code transform would be ideal for this scenario because manual annotation would probably be cumbersome. This could also be marketed as a **DEV-only transform** so as not to bloat production bundles with display names. We might even try to detect the env and throw if it isn't DEV (like https://github.com/facebook/react/pull/15939).\r\n\r\n## Further considerations\r\n\r\n### Custom hooks?\r\n\r\nIn some cases, custom hooks might also be ambiguous. Consider the `useSubscription` hook (https://github.com/facebook/react/pull/15022):\r\n```js\r\nfunction Example() {\r\n  const foo = useSubscription(...);\r\n  const bar = useSubscription(...);\r\n\r\n  // ...\r\n}\r\n```\r\n\r\nCurrently in DevTools the above component would be displayed as follows:\r\n```\r\nSubscription: \"some value\"\r\n  State: Object\r\nSubscription: \"some other  value\"\r\n  State: Object\r\n```\r\n\r\nMaybe the value alone (provided by `useDebugValue`) could be enough to uniquely identify the hook, but I suspect in many cases it might not be sufficient. Should we then use `useDebugName` for custom hooks as well?\r\n\r\nI think it would be more fragile given the way our custom hooks detection logic is implemented. Custom hooks are not identified until after a component has finished rendering. In order for us to associate names with custom hooks, we would need to maintain a stack of names. This could lead to potential mismatches though in the event that `useDebugName` was called more (or fewer) times than there are custom hooks.\r\n\r\nFor example, consider the following code:\r\n```js\r\nfunction useSomeCustomHook() {\r\n  const [foo, setFoo] = useState(true);\r\n  useDebugName(\"foo\");\r\n  useDebugName(\"effectively ignored\");\r\n  const [bar, setBar] = useState(false);\r\n  const [baz, setBaz] = useState(false);\r\n  useDebugName(\"baz\");\r\n\r\n  // ...\r\n}\r\n````\r\n\r\nThe proposed implementation of `useDebugName` would be robust enough to handle naming \"foo\" and \"baz\" states and leaving \"bar\" as anonymous state hook. If we were maintaining a stack of names however, this discrepency would be more difficult to manage.\r\n\r\nPerhaps there is a clever solution to this problem. I would probably suggest leaving it out of the initial implementation though and only revisiting if we determine it's a necessary feature.\r\n\r\n## Alternatives considered\r\n\r\n### Pass debug name as an additional (unused) parameter\r\n\r\nAn alternative approach to calling a separate hook for naming purposes would be to pass the display name as an additional parameter to the native hook, e.g.:\r\n```js\r\nfunction useSomeCustomHook() {\r\n  const [foo, setFoo] = useState(true, \"foo\");\r\n  const [bar, setBar] = useState(false, \"bar\");\r\n\r\n  // ...\r\n}\r\n\r\nfunction Example() {\r\n  const baz = useSomeCustomHook();\r\n\r\n  // ...\r\n}\r\n```\r\n\r\n**Pros**:\r\n* Less code.\r\n* Does not introduce a new hook.\r\n\r\n**Cons**:\r\n* It requires knowledge about the arity of native hooks. Ror example `useReducer` has optional parameters that the transform (or manual code) would need to be aware of to avoid a runtime error.\r\n* It would not be possible to support naming custom hooks (if that's something we decided to do).\r\n\r\n### Load source code (with source maps) and parse for name\r\nWe could use an extension API like [`Resource.getContent`](https://developer.chrome.com/extensions/devtools_inspectedWindow#method-Resource-getContent) to load the source code (including custom hooks) and parse it determine the hook/variable names. Essentially this would work like the proposed transform above, but at runtime.\r\n\r\n**Pros**:\r\n* Does not require a Babel transform step. (\"Just works\")\r\n* Does not potentially bloat production builds (if transform is used incorrectly).\r\n\r\n**Cons**:\r\n* Adds additional async loading (complexity) to suspense cache used for hooks inspection.\r\n* May have difficulty parsing certain code patterns (e.g. Babel's destructuring transform) unless we embed a full parser.\r\n\r\n### Call `toString` on the function component and parse for name\r\nA possible 80/20 variant of the above proposal would be to simply call` toString` on the function component and parse any top-level hooks.\r\n\r\n**Pros**:\r\n* Does not require a Babel transform step. (\"Just works\")\r\n* Does not potentially bloat production builds (if transform is used incorrectly).\r\n* Does not require any additional asynchronous code.\r\n\r\n**Cons**:\r\n* Only supports top-level hooks (used directly within the function).\r\n* May have difficulty parsing certain code patterns (e.g. Babel's destructuring transform) unless we embed a fullp parser.\r\n\r\n### Use a Babel transform to leave an inline comment (and call `toString` to search for it)\r\nRather than inserting a call to a new custom hook, our code transform could just insert an inline comment with the name. We could then parse the code to find the inline comment, e.g.:\r\n```js\r\nfunction Example() {\r\n  /* hook:foo:Example.react.js:3 */\r\n  const foo = useSubscription(...);\r\n  /* hook:bar:Example.react.js:5 */\r\n  const bar = useSubscription(...);\r\n\r\n  // ...\r\n}\r\n```\r\n\r\n**Pros**:\r\n* Does not potentially bloat production builds (if transform is used incorrectly).\r\n* Potentially sidesteps difficulty of parsing certain code patterns (e.g. Babel's destructuring transform).\r\n\r\n**Cons**:\r\n* Only supports top-level hooks (used directly within the function).\r\n* Still requires an explicit transform step.\r\n\r\n---\r\nOriginally reported via https://github.com/bvaughn/react-devtools-experimental/issues/323",
  "closed_by": null
}
