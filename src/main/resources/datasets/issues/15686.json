{
  "url": "https://api.github.com/repos/facebook/react/issues/15686",
  "repository_url": "https://api.github.com/repos/facebook/react",
  "labels_url": "https://api.github.com/repos/facebook/react/issues/15686/labels{/name}",
  "comments_url": "https://api.github.com/repos/facebook/react/issues/15686/comments",
  "events_url": "https://api.github.com/repos/facebook/react/issues/15686/events",
  "html_url": "https://github.com/facebook/react/pull/15686",
  "id": 446151267,
  "node_id": "MDExOlB1bGxSZXF1ZXN0MjgwNDE4MzMw",
  "number": 15686,
  "title": "[Fresh] Support re-rendering lazy() without losing state",
  "user": {
    "login": "gaearon",
    "id": 810438,
    "node_id": "MDQ6VXNlcjgxMDQzOA==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/810438?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gaearon",
    "html_url": "https://github.com/gaearon",
    "followers_url": "https://api.github.com/users/gaearon/followers",
    "following_url": "https://api.github.com/users/gaearon/following{/other_user}",
    "gists_url": "https://api.github.com/users/gaearon/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gaearon/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gaearon/subscriptions",
    "organizations_url": "https://api.github.com/users/gaearon/orgs",
    "repos_url": "https://api.github.com/users/gaearon/repos",
    "events_url": "https://api.github.com/users/gaearon/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gaearon/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 196858374,
      "node_id": "MDU6TGFiZWwxOTY4NTgzNzQ=",
      "url": "https://api.github.com/repos/facebook/react/labels/CLA%20Signed",
      "name": "CLA Signed",
      "color": "e7e7e7",
      "default": false
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2019-05-20T14:33:11Z",
  "updated_at": "2019-05-20T14:59:19Z",
  "closed_at": "2019-05-20T14:47:28Z",
  "author_association": "MEMBER",
  "pull_request": {
    "url": "https://api.github.com/repos/facebook/react/pulls/15686",
    "html_url": "https://github.com/facebook/react/pull/15686",
    "diff_url": "https://github.com/facebook/react/pull/15686.diff",
    "patch_url": "https://github.com/facebook/react/pull/15686.patch"
  },
  "body": "Follow-up to https://github.com/facebook/react/pull/15681.\r\n\r\nSay you have `App.js` which imports `Button.js` using a lazy dynamic import.\r\n\r\n```js\r\n// In App.js\r\nconst Button = lazy(() => import('./Button'));\r\n```\r\n\r\nWith https://github.com/facebook/react/pull/15681 alone, you can edit `Button.js` and that will preserve Button's state. However, before this PR editing `App.js` would always remount Button. This is because `newLazyType !== prevLazyType`.\r\n\r\nThis PR solves it in the same way we solve it for `forwardRef` and `memo`. We expect that the transform will \"register\" the wrapped type separately *at the callsite*:\r\n\r\n```js\r\nconst Button = lazy(() => import('./Button'));\r\n__register__(Button, 'App.js$Button'); // Generated by the transform\r\n```\r\n\r\nWhen reconciling, we'll always check families when `element.type` is a lazy wrapper, and if the family matches, avoid blowing away the state.\r\n\r\nNote that we don't do anything with a new Promise factory. We just ignore it, as we expect in the vast majority of cases the Promise factory to be stable and a thin wrapper over an `import` call. (If desired, we could later make it more cautious by attaching some kind of signature â€” similar to how we handle Hooks.) By ignoring the Promise factory, we rely on the inner type registration in `Button.js` to actually reflect the hot update.\r\n\r\nIn theory we could simply allow it to Suspend for a little bit, and then somehow make it work with the normal lazy resolution codepath. This would let us gracefully handle changes to the inner expression. However that would only work in Concurrent Mode. It doesn't seem worth it, especially given that we can already do something similar using build-time signatures.",
  "closed_by": {
    "login": "gaearon",
    "id": 810438,
    "node_id": "MDQ6VXNlcjgxMDQzOA==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/810438?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gaearon",
    "html_url": "https://github.com/gaearon",
    "followers_url": "https://api.github.com/users/gaearon/followers",
    "following_url": "https://api.github.com/users/gaearon/following{/other_user}",
    "gists_url": "https://api.github.com/users/gaearon/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gaearon/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gaearon/subscriptions",
    "organizations_url": "https://api.github.com/users/gaearon/orgs",
    "repos_url": "https://api.github.com/users/gaearon/repos",
    "events_url": "https://api.github.com/users/gaearon/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gaearon/received_events",
    "type": "User",
    "site_admin": false
  }
}
